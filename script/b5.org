# -*- coding: utf-8; -*-
#+OPTIONS: ^:{}
#+TITLE: B5: Web Services 
#+AUTHOR: Marc Wilhelm Küster

#+BEGIN_HTML
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">B5 "Web Services"</span> by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Marc Wilhelm Küster</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/mwkuster/b5" rel="dct:source">https://github.com/mwkuster/b5</a>.
#+END_HTML
* Objectives and Formalia
Session <2013-10-04 Fri>
** Course objectives
Mastering the concepts and implementation of heterogeneous, loosely-coupled architectures using a substantial practical programming project


** Programming project
Course success is measured through a practical programming project,
followed by a short oral exam. This project can be started after the
basic web service part is over. I will suggest topics, but
participants can also propose their own projects as long as the
technologies fit in the overall scope of the course.

You can and should work in teams of two.

Precondition for participating in the practical programming project is regular participation in the practical courses. You must pass at least 80% of the weekly assignments. An assignment is considered a pass if you have at least 50 of points out of 100.

Repeating the exam means a second, new practical project followed by a second oral exam.

** Preconditions
- Registration for course and exam within deadlines
- Participating in the final exam depends on having successfully completed a practical programming project
- Solid programming expertise
- Exam: consists of a practical programming project followed by a presentation and an oral exam
  
* RESTful Web Services and Resource Oriented Architectures
** The HTTP protocol
The Hypertext Transfer Protocol (HTTP) or RFC 2616 is next to the Uniform Resource Identifier (URI) the most important standard for the Web as we know it. Whenever we access anything on the web through a browser, we trigger at least one HTTP request, typically many. And not only through a browser: any mobile device uses HTTP requests, as do many software tools that are not browsers at all. 
               
In this session we will learn more about this specification and how it is used. Fortunately, the specification {Fielding:1999ub} itself is very clear and readable. It sets out with the HTTP's overall objective:
               
#+BEGIN_QUOTE  
The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems. It is a generic, stateless, protocol which can be used for many tasks beyond its use for hypertext, such as name servers and distributed object management systems, through extension of its request methods, error codes and headers. A feature of HTTP is the typing and negotiation of data representation, allowing systems to be built independently of the data being transferred (http://www.w3.org/Protocols/rfc2616/rfc2616.html)
#+END_QUOTE    
               
The key phrase --- and probably the main technical reason for HTTP's success --- is /stateless/. Generally, HTTP operates on pairs of request and response. Once a request has received its response, the protocol keeps no memory of the interaction, making each interaction independent. Of course, an HTTP request can very well change the state of the recipient, for example by adding a resource --- we'll shortly see how ---, but this remains transparent for the next request / response pair. The next interaction has no inherent knowledge if the state of the server has just been changed a millisecond earlier, was changed a month ago or has always been in this state: "interaction is stateless between requests" ({Fielding:2000vh}, 5.3.1). The server also has no need to keep a state related to the concrete set of interactions, nor even which sequence of interactions come from the same sender. "Session state is therefore kept entirely on the client" ({Fielding:2000vh}, 5.1.3).
               
If this sounds abstract, at the core it means that a sender --- let's say, the browser --- asks a server for a webpage, giving a URI to identify that page:
               
#+BEGIN_EXAMPLE
 -----------   Get Webpage       ----------
 |         | ------------------> |        |
 | Browser |                     | Server |
 |         | <------------------ |        |
 -----------  Send webpage       ----------
#+END_EXAMPLE

In reply, the server sends back the content of that website to the browser, and that's it.

Of course, there's a bit more to it, though the principle does not change.

*** HTTP methods and their use
**** GET-method
In the easiest scenario, the client just wants to get some content from the server. In this case sends a request that is in fact just called ~GET~:
#+BEGIN_EXAMPLE
$curl -v http://www.budabe.eu/research/
--> 
GET /research/ HTTP/1.1
User-Agent: curl/7.27.0
Host: www.budabe.eu
Accept: */*
#+END_EXAMPLE

This says pretty much what it seems to say: request the server to ~GET~ the URL webpage ~/research~ on the host ~www.budabe.eu~ and return its contents. If the page exists, the server responds by sending it back:

#+BEGIN_EXAMPLE
< HTTP/1.1 200 OK
< Date: Sat, 22 Sep 2012 15:09:33 GMT
< Server: Apache/2.2.20 (Ubuntu)
< Vary: Accept-Language,Cookie,Accept-Encoding
< Content-Language: de-de
< Transfer-Encoding: chunked
< Content-Type: text/html; charset=utf-8
< 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><!-- mode: nxml; code: utf-8; -->
<html version="-//W3C//DTD XHTML 1.1//EN" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>
Research
</title>
[...]
#+END_EXAMPLE

Again, this says pretty much what it seems to say: On a given date the server sends back an html-page (-Content-Type: text/htm-) encoded in Unicode and more precisely UTF-8. The most cryptic and at the same time the most important part of this is the ~200~ part, though, that says that the request has succeeded. The ~200~ return code is specified RFC 2616 alongside 37 others. We'll come back to these codes below.

Formally, ~GET~ is defined as:

#+BEGIN_QUOTE 
The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI. If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not the source text of the process, unless that text happens to be the output of the process ({Fielding:1999ub}, 9.3)
#+END_QUOTE

~GET~ returns existing webpages or more abstractly resources, if they exist, but it does not modify it. You can execute it any number of times, it will always return the resource. For this reason, it is called an idempotent method.

**** HEAD-method
"The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response" ({Fielding:1999ub}, 9.4):
#+BEGIN_EXAMPLE$ curl -v -XHEAD  http://www.budabe.eu/research/
$ curl -v -XHEAD  http://www.budabe.eu/research/ 
-->
> HEAD /research/ HTTP/1.1
> User-Agent: curl/7.27.0
> Host: www.budabe.eu
> Accept: */*
> 
< HTTP/1.1 200 OK
< Date: Sat, 22 Sep 2012 15:31:18 GMT
< Server: Apache/2.2.20 (Ubuntu)
< Vary: Accept-Language,Cookie,Accept-Encoding
< Content-Language: de-de
< Content-Type: text/html; charset=utf-8
 no chunk, no close, no size. Assume close to signal end
< 
#+END_EXAMPLE

Since the server does not return data, it is a quick way to test if a resource exists, is accessible and / or has recently been modified. Like ~GET~ ~HEAD~ is also idempotent.

**** DELETE-method
Another idempotent method is ~DELETE~ that does exactly what you'd assume it does: "The DELETE method requests that the origin server delete the resource identified by the Request-URI" ({Fielding:1999ub}, 9.7):

#+BEGIN_EXAMPLE
$ curl -v -XDELETE  http://www.budabe.eu/research/
-->
> DELETE /research/ HTTP/1.1
> User-Agent: curl/7.27.0
> Host: www.budabe.eu
> Accept: */*
> 
#+END_EXAMPLE

Of course, this does not mean that the sender has necessarily the right to do this and that the server will actually delete a resource. In this case, the server return a ~403~ (= forbidden) to indicate that it has no intention to delete it:
#+BEGIN_EXAMPLE
< HTTP/1.1 403 FORBIDDEN
< Date: Sat, 22 Sep 2012 15:28:08 GMT
< Server: Apache/2.2.20 (Ubuntu)
< Vary: Accept-Language,Cookie,Accept-Encoding
< Content-Language: de-de
< Transfer-Encoding: chunked
< Content-Type: text/html
< 
#+END_EXAMPLE

~DELETE~ is also idempotent in that we can issue it any number of times, the result will always be the same (i.e. given necessary rights the resource will have disappeared).

**** PUT-method
Another idempotent method is the ~PUT~ method. It "requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI. If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response" ({Fielding:1999ub}, 9.6). In other words, the client asks the server to generate a new resource or update an existing one for a given URI. The server has no leaway, it must create or update the resource under that URI or refuse the action.

In the following example the server is requested to create a page ~/research/WebService~ that currently does not exist:

#+BEGIN_EXAMPLE
$ curl -v -XPUT -d "01234567890123456789012345"  http://www.budabe.eu/research/WebService
-->
> PUT /research/WebService HTTP/1.1
> User-Agent: curl/7.27.0
> Host: www.budabe.eu
> Accept: */*
> Content-Length: 26
> Content-Type: application/x-www-form-urlencoded
> 
 upload completely sent off: 26 out of 26 bytes
#+END_EXAMPLE

As a payload, the string "Data for this new resource", which has a length of 26 bytes, is sent along.

Of course, as always the fact that you can send a ~PUT~ request to the server does not mean you have the necessary rights.

#+BEGIN_EXAMPLE
< HTTP/1.1 403 FORBIDDEN
< Date: Sun, 23 Sep 2012 10:08:50 GMT
< Server: Apache/2.2.20 (Ubuntu)
< Vary: Accept-Language,Cookie,Accept-Encoding
< Content-Language: de-de
< Transfer-Encoding: chunked
< Content-Type: text/html
#+END_EXAMPLE

Similarly, the following request asks for an update to an existing resource with the same 26 characters: 

#+BEGIN_EXAMPLE
$ curl -v -XPUT -d "01234567890123456789012345"  http://www.budabe.eu/research/WebService
-->
> PUT /research/ HTTP/1.1
> User-Agent: curl/7.27.0
> Host: www.budabe.eu
> Accept: */*
> Content-Length: 26
> Content-Type: application/x-www-form-urlencoded
> 
 upload completely sent off: 26 out of 26 bytes
#+END_EXAMPLE

If this had succeeded, the (existing) page http://www.budabe.eu/research/ would now have the new content.

Since the precondition for ~PUT~ is that the client knows the URI to which the data sent will be applied, this method is virtually always used ot update existing resources, not to create new ones.

If you had the rights, the answer would obligatorily have been ~201~ in both cases.

**** POST-method
If ~PUT~ normally updates existing resources, ~POST~ ist used to create new resources under a given URI. The client does not know in advance what the new URI will be, but will be informed by the server about this when things go according to plan. The server has a certain flexibility in interpreting the right action:

#+BEGIN_QUOTE  
The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI. The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it, a news article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database.
#+END_QUOTE  

Possible positive responses are:

- 200 (OK) or 204 (No Content) if no resource was created, but the action want OK
- 201 (Created) with a reference to the new resource if a new resource was created


*** Error handling
One of the strenghts of the HTTP protocol is that it has a clear semantics for handling possible errors through well-defined response codes. Leaving aside the hardly-ever used 1xx series of responses we have:

- Successful 2xx 
  - 200 OK 
  - 201 Created 
  - 202 Accepted 
  - 203 Non-Authoritative Information 
  - 204 No Content 
  - 205 Reset Content 
  - 206 Partial Content 
- Redirection 3xx 
  - 300 Multiple Choices 
  - 301 Moved Permanently 
  - 302 Found 
  - 303 See Other 
  - 304 Not Modified 
  - 305 Use Proxy 
  - 306 (Unused) 
  - 307 Temporary Redirect 
- Client Error 4xx 
  - 400 Bad Request 
  - 401 Unauthorized 
  - 402 Payment Required 
  - 403 Forbidden 
  - 404 Not Found 
  - 405 Method Not Allowed 
  - 406 Not Acceptable 
  - 407 Proxy Authentication Required 
  - 408 Request Timeout 
  - 409 Conflict 
  - 410 Gone 
  - 411 Length Required 
  - 412 Precondition Failed 
  - 413 Request Entity Too Large 
  - 414 Request-URI Too Long 
  - 415 Unsupported Media Type 
  - 416 Requested Range Not Satisfiable 
  - 417 Expectation Failed 
- Server Error 5xx 
  - 500 Internal Server Error 
  - 501 Not Implemented 
  - 502 Bad Gateway 
  - 503 Service Unavailable 
  - 504 Gateway Timeout 
  - 505 HTTP Version Not Supported 

*** Content negotiation 
So far we have seen only requests with the HTTP header ~Accept: */*~, which essentially says that you have no preference for the type of content to get back. However, normally clients have preferences for some type of content in some language over other types of content. In a typical browser session we see sequences like this:

#+BEGIN_EXAMPLE
Request:
http://www.budabe.eu/research/

GET /research/ HTTP/1.1
Host: www.budabe.eu
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:12.0) Gecko/20100101 Firefox/12.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: de-de,de;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate

Response:
HTTP/1.1 200 OK
Date: Sun, 23 Sep 2012 17:19:33 GMT
Server: Apache/2.2.20 (Ubuntu)
Vary: Accept-Language,Cookie,Accept-Encoding
Content-Language: de
Content-Encoding: gzip
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html; charset=utf-8
#+END_EXAMPLE
(protocol of a live session taken with the Live HTTP headers plugin in Firefox)

In contrast to the HTTP method the HTTP headers always follow the model: Header name ':' value of the header followed by a newline (theoretically a line continuation is possible, but rarely seen) (cf. {Fielding:1999ub}, 2.2 for the details of the BNF rules). In particular, ~Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8~
 requests in the order of preference ~text/html~ and XHTML (~application/xhtml+xml~), then other formats. The server is expected to honour these requests. Similarly, ~Accept-Language~ specifies a preference for German (~de~) over English (~en~). More languages are possible.

The very same logic can also be used for more web-service type requests to deliberatedly ask for some languages or content types.

*** Assignment
1. Pick a website of your choice and download it using curl. Execute then DELETE, PUT and POST requests with curl
2. Do the same exercise directly using telnet [domain] 80

Copy the protocol of your terminal session into a text file and upload it. Hand in the assignment via the course's Moodle page.

*** Command line tools such as curl and wget
~curl~ (http://curl.haxx.se/) is a standard tool to download websites via the command line or (through ~libcurl~) programmatically:
#+BEGIN_EXAMPLE
curl -v -L -H "Host:www.budabe.eu" -H "Accept:application/xhtml+xml,text/html;q=1.0,text/xml;q=0.9" -H "Accept-Language:de" "http://www.budabe.eu/research"
#+END_EXAMPLE

will return the German-language version of the webpage ~http://www.budabe.eu/research~, with preference in XHTML. The following command, in turn, will return the English language representation:

#+BEGIN_EXAMPLE
curl -v -L -H "Host:www.budabe.eu" -H "Accept:application/xhtml+xml,text/html;q=1.0,text/xml;q=0.9" -H "Accept-Language:en" "http://www.budabe.eu/research"
#+END_EXAMPLE

~wget~ (http://www.gnu.org/software/wget/) has similar functionalities, though more targeted towards web crawling.


*** Encryption and caching
Because of its statelessness HTTP is easy to combine with encryption and caching. For encryption the by far most frequent way is HTTP over Secure Sockets Layer (SSL) or Transport Layer Security (TLS). From the perspective of the HTTP protocol this encryption is transparent.

For caching, HTTP foresees a set of explicit HTTP headers for this purpose:

- ~Last-Modified~: Indicates when the resource was last changed. This is typically retrieved with a cheap ~HEAD~ request. If ~Last-Modified~ is newer than the latest cached version, the cache should be updated accordingly
- ~ETag~: A response header to enable cache validation

The details of cache handling are beyond this script, cf. {Fielding:1999ub}, chapter 13 for all the details. There are a number of Open Source and proprietary caching solution out there including Squid (http://www.squid-cache.org/), Varnish Cache (https://www.varnish-cache.org/about) and many others. In modern architectures, very often also Non-SQL databases are used for this prupose.

** Design principles for RESTful systems


RESTful systems are, as the name suggests, systems on Representational State Transfer. This hints at Fielding's key idea in his famous dissertation is to see the entire web as a single monstrous state machine --- "Hypermedia as the engine of application state" ---, operated by "uniform interface between components" ({Fielding:2000vh}, 5.1.5). The web centres on resources --- "any information that can be named" (5.2.1.1) --- that are uniquely identified by URIs. A resource is in principle independent of its concrete representation, e.g. as HTML or pdf. Clients and server can use content negoation to mutually agree on a suitable representation of a resource. Hence, "REST-based architectures communicate primarily through the transfer of representations of resources" (5.3.3). 

In this concept application state is "the state that the server needs to maintain between each request for each client" ({Allamaraju:2010ty}, p. 7). References to application state or indeed at time the application state itself is coded into URIs and sent with the representation to link to new application states.

A Resource Oriented Architecture (ROA) is "an arrangement of URIs, HTTP, and XML that works like the rest of the Web, and that programmers will enjoy using" ({Richardson:2007td}, chapter 4), the term being coinded as an antithesis to Service Oriented Architectures (SOAs). ROAs embrace RESTful principles and systematize key ideas. 

A ROA is characterized by the key tenents of RESTful systems, i.e.:

- Addressable: each resource is addresable through a URI
- Stateless: each HTTP request standard for itself. It contains all information that the server needs to process the request (it can change the server's resource state, though)
- Links: Links point to possible new states of this or another application
- Uniform interface, i.e. the HTTP methods (polymorphism of HTTP methods, {Dillon:2007hb})



* Excursion: Ruby
More details on Ruby in the Prezi http://prezi.com/_vwryy7ngvj6/?utm_campaign=share&utm_medium=copy&rc=ex0share and online in various tutorials


* Programming RESTful Web Services: Client side web services
Session: <2013-10-25 Fri>

In our first session we've learned about the HTTP protocol as the technical underpinning for RESTful Web Services. In fact, on the protocol level RESTful Web Services just operate HTTP request / response pairs, using the full set of HTTP methods. In this second phase we're going into more details on other aspects of the design of RESTful Web Services as well as the "RESTful" philosophy. 

** Design of URIs
Maybe the most overlooked aspect of RESTful Web Services is the need for "cool URIs". "A cool URI is one which does not change" ({BernersLee:1998ui}):
#+BEGIN_QUOTE
It is the the duty of a Webmaster to allocate URIs which you will be able to stand by in 2 years, in 20 years, in 200 years. This needs thought, and organization, and commitment.
#+END_QUOTE

Berners-Lee proposes that a good URI must remain stable over time. For this it should leave out of the URIs:
- Author's names
- Subject classifications
- Status information (old, new etc.)
- Access rights
- File name extensions
- Implementation details (e.g. ~/cgi-bin/~ or similar)

Instead, he proposes to use stable information such as the original creation date. 

For URIs referring to real-life objects such as persons, {Anonymous:2008vd}, 4.5 proposes to follow three design goals:
- Simplicity
- Stability
- Manageability

*** URI Templates
Remains the question on how to transpose these principles into concrete URIs and how to document the resulting URI patterns. RFC 6570 "URI templates" (http://tools.ietf.org/html/rfc6570 / {Gregorio:2012vo}) defines a template language to document and automatically fill URI templates. The specification defines four levels of compliance. At its simplest, URI templates define string substitutions (compliance level 1):

#+BEGIN_EXAMPLE
http://www.budabe.eu/{section}/{subsection}

section := "research"
subsection := "DigitalHumanities"

-->
http://www.budabe.eu/research/DigitalHumanities
#+END_EXAMPLE

If necessary, strings are URI encoded, e.g. ~http://www.budabe.eu/research/Digital%20Humanities~ if ~subsection := Digital Humanities~. Variables can occur both at the level of URIs and query parameters.

Level 2 adds handling of reserved characters that would otherwise be URI encoded. You achieve this goal by adding a ~+~ as the first character of the variable:
#+BEGIN_EXAMPLE
http://www.budabe.eu/{section}
section := "research/Digital Humanities"
-->
http://www.budabe.eu/research%2FDigital%20Humanities

but

http://www.budabe.eu/{+section}
section := "research/Digital Humanities"
-->
http://www.budabe.eu/research/Digital%20Humanities
#+END_EXAMPLE

Similarly, if the first character is a hash (~#~), the resulting string contains the hash:

#+BEGIN_EXAMPLE
http://www.budabe.eu/{#section}
section := "Digital Humanities"
-->
http://www.budabe.eu/#Digital%20Humanities
#+END_EXAMPLE

Level 3 add "multiple variables per expression, each separated by a comma, and add more complex operators for dot-prefixed labels, slash-prefixed path segments, semicolon-prefixed path parameters, and the form-style construction of a query syntax consisting of name=value pairs that are separated by an ampersand character" (RFC 6570, p. 5):

#+BEGIN_EXAMPLE
http://www.budabe.eu/{+section,subsection}
section := "research"
subsection := "Digital Humanities"
-->
http://www.budabe.eu/research,Digital%20Humanities
#+END_EXAMPLE

Similarly, if the first character is a ~/~, the template is treated as a path (and, in the case of ~#~ as an anchor):

#+BEGIN_EXAMPLE
http://www.budabe.eu{/section,subsection}       
(note that there is no slash behind .eu)
section := "research"
subsection := "Digital Humanities"
-->
http://www.budabe.eu/research/Digital%20Humanities
#+END_EXAMPLE

If a part of the variables are not given for substitution, the corresponding part is just left out:
#+BEGIN_EXAMPLE
http://www.budabe.eu{/section,subsection}       
section := "research"
-->
http://www.budabe.eu/research

http://www.budabe.eu{/section,subsection}       
subsection := "Digital Humanities"
-->
http://www.budabe.eu/Digital%20Humanities
#+END_EXAMPLE

The same applies if the first character is a ~?~ or ~&~, in which case all arguments are treated as query string parameters. 

Level 4 adds the ability to slighly modify values during variable substitution by adding a ~:~ at the end:
#+BEGIN_EXAMPLE
http://www.budabe.eu{/section:4}
section := "research"
-->
http://www.budabe.eu/rese
#+END_EXAMPLE

Likewise, a ~*~ at the end permits the handling of multiple values in lists or similar:

#+BEGIN_EXAMPLE
http://www.budabe.eu/{section*}
section := ("research", "Digital Humanities")
-->
http://www.budabe.eu/research,Digital%20Humanities
#+END_EXAMPLE

Pre- and postfix modifiers can be combined:

#+BEGIN_EXAMPLE
http://www.budabe.eu{/section*}
section := http://www.budabe.eu{/section*}
--> 
http://www.budabe.eu/research/Digital%20Humanities
#+END_EXAMPLE

RFC 6570 also has a semi-official test suite https://github.com/uri-templates/uritemplate-test. The examples given in this test suite help to understand many of the edge cases.

*** The case of the European Legislation Identifier (ELI)
The European Legislation Identifier (ELI / http://register.consilium.europa.eu/pdf/en/12/st13/st13401.en12.pdf, cf. also http://europa.eu/rapid/pressReleasesAction.do?reference=IP/12/1040&format=HTML&aged=0&language=EN&guiLanguage=en), published as a Council Conclusions 13401/12,  is a scheme to express laws through URIs. Every member state can flexibly express their own online resources for legislation, however using common variables that can be used to build concrete URI templates. The following variables are in principle foreseen:

#+BEGIN_EXAMPLE
{jurisdiction} {agent} {sub-agent} {year} {month} {day } {type} {natural identifier} {level 1…} {point in time} {version} {language}
#+END_EXAMPLE

The semantics of these template components is well defined within the Council Conclusions (cf. p. 9).

Concrete URI templates for European Legislation can look like this:

#+BEGIN_EXAMPLE
http://eur-lex.europa.eu/eli{/type}{/year}{/natural_identifier,version,language}
#+END_EXAMPLE

The type of legislation is in this case identified by a language-independent code, e.g. ~reg~ for ~regulation~ or ~dir~ for directive. Likewise, ~agent~ can be the code for zero to many actors in the European legislative process, e.g. ~ep~ for the European Parliament or ~consil~ for the Council of the European Union. ~year~ is the year in which the legislation was passed and the natural identifier is typically a running number given to a specific type of legislation. The optional ~version~ can identify if this specific act is a corrigendum, e.g. ~R1~. ~language~ optionally identifies a language version of an act.

So, for the Public Sector Information Directive 2003/98/EC of the European Parliament and of the Council of 17 November 2003 in English the ELI would be as follows:

#+BEGIN_EXAMPLE
http://eur-lex.europa.eu/eli{/type}{/year}{/natural_identifier,version,language}

type := "dir"
year := 2003
natural_identifier := 98
language := "ENG"
-->
http://eur-lex.europa.eu/eli/dir/2003/98/ENG
#+END_EXAMPLE

The third corrigendum of the same act in Spanish has the ELI:
#+BEGIN_EXAMPLE
http://eur-lex.europa.eu/eli{/type}{/year}{/natural_identifier,version,language}

type := "dir"
year := 2003
natural_identifier := 98
version := "R3"
language := "SPA"
-->
http://eur-lex.europa.eu/eli/dir/2003/98/R3/SPA
#+END_EXAMPLE

ELIs follow a logic of search: individual legal resources have metadata elements such as ~type~ or ~agent~, an ELI identifies the resource that corresponds to that combination of metadata. By construction, there is maximally one such resource.

This logic, however, generalizes also to URI templates that identify a set of resources, e.g.:

All legal resources of a given type in a year with its natural identifier regardless of their creating agent:

#+BEGIN_EXAMPLE
http://eur-lex.europa.eu/eli{/type}{/year}{/natural_identifier,version,language}
#+END_EXAMPLE

All legal resources of a given type in a given year:

#+BEGIN_EXAMPLE
http://eur-lex.europa.eu/eli{/type}{/year}
#+END_EXAMPLE

All legal resources of a given type:

#+BEGIN_EXAMPLE
http://eur-lex.europa.eu/eli{/type}
#+END_EXAMPLE

All legal resources in a given year regardless of its type:

#+BEGIN_EXAMPLE
http://eur-lex.europa.eu/eli{/year}
#+END_EXAMPLE

And finally all legal resources of a given type from one or more given agents:
#+BEGIN_EXAMPLE
http://eur-lex.europa.eu/eli{/type}
#+END_EXAMPLE

Note: Previous  drafts of the ELI specification used multiple agents (= authors) in the URI as follows:
#+BEGIN_EXAMPLE
http://eur-lex.europa.eu/eli{/type}{/agents*}{/year}{/natural_identifier,version,language}

type := "dir"
agent := ("ep", "consil")
year := 2003
natural_identifier := 98
language := "ENG"
-->
http://eur-lex.europa.eu/eli/dir/ep/consil/2003/98/ENG
#+END_EXAMPLE

The third corrigendum of the same act in Spanish had then the ELI:
#+BEGIN_EXAMPLE
http://eur-lex.europa.eu/eli{/type}{/agents*}{/year}{/natural_identifier,version,language}

type := "dir"
agent := ("ep", "consil")
year := 2003
natural_identifier := 98
version := "R3"
language := "SPA"
-->
http://eur-lex.europa.eu/eli/dir/ep/consil/2003/98/R3/SPA
#+END_EXAMPLE

*** URITemplates in Ruby

Multiple Ruby libraries exist to handle URI Templates up to level 4. I use here Addressable: http://addressable.rubyforge.org/ and http://rubyforge.org/projects/addressable/. The API documentation of addressable is available under http://addressable.rubyforge.org/api/

Addressable must be installed as a normal Ruby gem:

#+BEGIN_EXAMPLE
sudo gem install addressable
#+END_EXAMPLE

Addressable is at its source a URI handling library that goes beyond the standard Ruby URI class and includes amongst others URI templates. Using the library works as follows:
#+BEGIN_EXAMPLE
#Taken from http://addressable.rubyforge.org/api/
require "addressable/uri"

uri = Addressable::URI.parse("http://example.com/path/to/resource/")
uri.scheme
#=> "http"
uri.host
#=> "example.com"
uri.path
#=> "/path/to/resource/"

require "addressable/template"

template = Addressable::Template.new("http://example.com/{-list|+|query}/")
template.expand({
  "query" => "an example query".split(" ")
})
#+END_EXAMPLE

For ELI URI templates the example according to the old ELI draft looks then like this:

#+BEGIN_EXAMPLE
require "addressable/template"

template = Addressable::Template.new("http://eur-lex.europa.eu/eli{/type}{/agents*}{/year}{/natural_identifier,version,language}")
uri = template.expand({
"type" => "dir", "agents" => ["ep", "consil"], "year" => 2003, "natural_identifier" => 98
})
#=> #<Addressable::URI:0x3fea68d21c24 URI:http://eur-lex.europa.eu/eli/dir/ep/consil/2003/98>
uri.to_s
#=> "http://eur-lex.europa.eu/eli/dir/ep/consil/2003/98"
#+END_EXAMPLE

A corresponding example for the Google query API and executed in TextMate 2.0:

[[img/google_query_executed_in_textmate.png]]


*** Excursion: Handling URITemplates in Clojure

The URITemplates implementation in Clojure, ~uritemplates-clj~ (https://github.com/mwkuster/uritemplate-clj), that I have developed for this purpose, has an extremely simple interface. It exposes a single method, ~uritemplate~, taking the URI template and a map of values as input and returning the URI with the filled in template:

#+BEGIN_EXAMPLE
user=> (ns test
  #_=> (:require [uritemplate-clj.core :as templ]))
nil
test=> (templ/uritemplate "http://example.org/abc{/type}{/year}{/natural_identifier,version,language}" {"type" "dir", 
  #_=>                "agent"  ["ep" "consil"], 
  #_=>                "year"  "2003",
  #_=>                "natural_identifier" "98"})
"http://example.org/abc/dir/ep/consil/2003/98"
test=> 
#+END_EXAMPLE

** JSON 
The JavaScript Object Notation or JSON (=
http://tools.ietf.org/html/rfc4627) at its simplest is just a subset
of JavaScript concerning only data. JSON uses UTF-8 and supports the
usual datatypes: "A JSON value MUST be an object, array, number, or
string, or one of the following three literal names: false null true" (2.1). Concretely, the following types exist (description follows RFC 4627):


- Number: an integer component that   may be prefixed with an optional minus sign, which may be followed by  a fraction part and/or an exponent part. Octal and hex forms are not allowed.  Leading zeros are not allowed
- String: string begins and ends with  quotation marks.  All Unicode characters may be placed within the   quotation marks except for the characters that must be escaped:   quotation mark, reverse solidus, and the control characters (U+0000   through U+001F). The string is encoded in UTF-8
- Boolean: true or false
- Array: square brackets surrounding zero or more values (or elements).  Elements are separated by commas
- Object: a pair of curly brackets   surrounding zero or more name/value pairs (or members).  A name is a   string.  A single colon comes after each name, separating the name   from the value. 
- null (empty)

We see many of these in action in the following extract taken from https://github.com/uri-templates/uritemplate-test/blob/master/extended-tests.json:

#+BEGIN_SRC JavaScript
{
    "Additional Examples 1":{
        "level":4,
        "variables":{
            "id"           : "person",
            "token"        : "12345",
            "fields"       : ["id", "name", "picture"],
            "format"       : "json",
            "q"            : "URI Templates",
            "page"         : "5",
            "lang"         : "en",
            "geocode"      : ["37.76","-122.427"],
            "first_name"   : "John",
            "last.name"    : "Doe", 
            "Some%20Thing" : "foo",
            "number"       : 6,
            "long"         : 37.76,
            "lat"          : -122.427,
            "group_id"     : "12345",
            "query"        : "PREFIX dc: <http://purl.org/dc/elements/1.1/> SELECT ?book ?who WHERE { ?book dc:creator ?who }",
            "word"         : "drücken",
            "Stra%C3%9Fe"  : "Grüner Weg",
            "random"       : "šöäŸœñê€£¥‡ÑÒÓÔÕÖ×ØÙÚàáâãäåæçÿ",
            "assoc_special_chars"  :
              { "šöäŸœñê€£¥‡ÑÒÓÔÕ" : "Ö×ØÙÚàáâãäåæçÿ" }
        }
}
#+END_SRC

For many languages and especially for dynamic languages JSON maps directly into the corresponding language structures. In Clojure the internal representation of this objects looks very similar to the JSON original and that's certainly no coincidence:

#+BEGIN_SRC Clojure
{"Additional Examples 1"
 {"level" 4, "variables" 
   {"random" "šöäŸœñê€£¥‡ÑÒÓÔÕÖ×ØÙÚàáâãäåæçÿ", 
   "last.name" "Doe", 
   "query" "PREFIX dc: <http://purl.org/dc/elements/1.1/> SELECT ?book ?who WHERE { ?book dc:creator ?who }",
   "number" 6, 
   "word" "drücken", 
   "assoc_special_chars" {"šöäŸœñê€£¥‡ÑÒÓÔÕ" "Ö×ØÙÚàáâãäåæçÿ"},
   "lang" "en", 
   "page" "5", 
   "q" "URI Templates", 
   "format" "json", 
   "Stra%C3%9Fe" "Grüner Weg", 
   "token" "12345", 
   "fields" ["id" "name" "picture"], 
   "first_name" "John", 
   "id" "person", 
   "group_id" "12345", 
   "long" 37.76, 
   "geocode" ["37.76" "-122.427"], 
   "lat" -122.427, 
   "Some%20Thing" "foo"
   } 
 }
}
#+END_SRC

Incidentally, the order of attributes in an object is undefined.

*** JSON and Ruby
JSON support is part of the Ruby standard library. It is essentionally centred around the two methods ~parse~ to parse received JSON structures into Ruby data structures and ~generate~ to generate JSON structures from Ruby's data structures:

#+BEGIN_SRC Ruby
test_obj = {:a => "a", "b" => "cd", 1 => "z", 2 => [1,2,3,4], 3 => {"i" => 7}}

j = JSON::generate(test_obj)
#=> "{\"a\":\"a\",\"b\":\"cd\",\"1\":\"z\",\"2\":[1,2,3,4],\"3\":{\"i\":7}}"

obj = JSON::parse(j)
#=> {"a"=>"a", "b"=>"cd", "1"=>"z", "2"=>[1, 2, 3, 4], "3"=>{"i"=>7}}
#+END_SRC


*** Excursion: JSON and Clojure
There are a number of Clojure libraries for JSON handling. The one we use here is Cheshire (https://clojars.org/cheshire), build on the Open Source Java Jackson library (http://wiki.fasterxml.com/JacksonHome). It is extremely easy to use:

#+BEGIN_SRC Clojure
(ns b5
  (:use [cheshire.core]))

(def extended-tests  
 (cheshire.core/parse-stream 
    (clojure.java.io/reader "test/uritemplate_clj/extended-tests.json")))
#+END_SRC

Similarly, Cheshire can easily map native Clojure maps to JSON:

#+BEGIN_SRC Clojure
(ns b5
  (:use [cheshire.core]))

(cheshire.core/generate-string {:a  "b", :b 5, "c" [1 2 3 4 5]})
-->
"{\"c\":[1,2,3,4,5],\"a\":\"b\",\"b\":5}"
#+END_SRC

** Assignment 
Take at your choice and depending on your language skills one of the websites

- http://www.legilux.public.lu/  (Luxembourg, in French)
- http://legimobile.fr/ (France)
- http://www.belgielex.be/ (Belgium, in French, Dutch, German and English, do search in "Législation belge", then check for frame source to see the links)
- http://legislation.gov.uk/  (UK)
- http://www.normattiva.it/ricerca/semplice (Italy)

and define a URI template for it. Test the pattern using the uritemplate-clj library or another URITemplate library of your choice and verify for at least 15 different URIs that the URIs that you generate actually exist.

Hand in via the course's Moodle page the:
- URI pattern defined
- script used to test that pattern
- list of at least 15 URIs generated and subsequently tested
  
  
** ATOM and related standards
Session <2013-10-26 Sat>

ATOM / RFC 4287 (= http://www.ietf.org/rfc/rfc4287.txt), which was incidentally created by the same person as the URI template specification, is next to RSS the most popular standard for content syndication. It is at the same time much more popular than RSS for machine-to-machine communication:
#+BEGIN_QUOTE
Atom is an XML-based document format that describes lists of related
information known as "feeds".  Feeds are composed of a number of
items, known as "entries", each with an extensible set of attached
metadata.  For example, each entry has a title.

The primary use case that Atom addresses is the syndication of Web
content such as weblogs and news headlines to Web sites as well as
directly to user agents. (RFC 4287 / {Gregorio:Z8RX-4sN})
#+END_QUOTE

The following extract is taken directly from the RFC:

#+BEGIN_EXAMPLE
<feed xmlns="http://www.w3.org/2005/Atom">
 <title>Example Feed</title>
 <link href="http://example.org/"/>
 <updated>2003-12-13T18:30:02Z</updated>
 <author>
  <name>John Doe</name>
 </author>
 <id>urn:uuid:60a76c80-d399-11d9-b93C-0003939e0af6</id>

 <entry>
  <title>Atom-Powered Robots Run Amok</title>
  <link href="http://example.org/2003/12/13/atom03"/>
  <id>urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a</id>
  <updated>2003-12-13T18:30:02Z</updated>
  <summary>Some text.</summary>
 </entry>
</feed>
#+END_EXAMPLE

ATOM feeds exist for many blogs, often alongside feeds in RSS. For further examples we will use  http://planet.clojure.in/atom.xml, but we could have used any number of other blogs.

#+BEGIN_EXAMPLE
curl http://planet.clojure.in/atom.xml | less
-->

<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Planet Clojure</title>
  <link rel="self" href="http://planet.clojure.in/atom.xml"/>
  <link href="http://planet.clojure.in/"/>
  <id>http://planet.clojure.in/atom.xml</id>
  <updated>2012-10-14T10:15:44+00:00</updated>
  <generator uri="http://www.planetplanet.org/">http://intertwingly.net/code/venus/</generator>
  <entry>
    <title type="html">Presentation: Distributed Apps: The Joys of Testing and Debugging</title>
    <link href="http://www.infoq.com/presentations/Clojure-Stack-Trace"/>
    <id>http://www.infoq.com/presentations/Clojure-Stack-Trace</id>
    <updated>2012-10-12T22:40:00+00:00</updated>
    <content type="html">Chris Houser discusses stack traces in Clojure and introduces a library for investigating activity across multiple threads and servers, plus a technique for reproducing race conditions. &lt;i&gt;By Chris Houser&lt;/i&gt;</content>
    <author>
            <name>Clojure at InfoQ</name>
            <uri>http://pipes.yahoo.com/pipes/pipe.info?_id=be83c0b5b0d92b259682cb8021e14d2a</uri>
    </author>
    <source>
            <title type="html">InfoQ Clojure-related materials</title>
            <subtitle type="html">Pipes Output</subtitle>
            <link rel="self" href="http://pipes.yahoo.com/pipes/pipe.run?_id=be83c0b5b0d92b259682cb8021e14d2a&amp;_render=rss"/>
            <id>http://pipes.yahoo.com/pipes/pipe.info?_id=be83c0b5b0d92b259682cb8021e14d2a</id>
    </source>
  </entry>
  <entry>
        [...]
   </entry>
   [...]
</feed>
#+END_EXAMPLE

ATOM uses the namespace ~http://www.w3.org/2005/Atom~. Some information is provided on the Feed level, notably the feed's title, an identifier (~id~), a link to the Atom feed itself (~link~ with rel="self") and possibly to its website and, most crucially, the last update data ~updated~ that allows a feed reader to decide if it needs to check for added or updated entries without downloading everything. The real content is then inside the individual ~entry~ elements, bringing the entry ~title~, a link to the corresponding web page, again the last ~updated~ timestamp for this entry and a summary (~content~), in this case formatted in basic HTML. Planet Clojure is special in that it is a feed of feeds that aggregates entries from a lot of smaller blogs. For this reason, it indicates the source of that information, together with links and ids.

ATOM is in this paradigmatic for RESTful design. It is transported via HTTP, is both machine and (with suitable readers) human readable and provides links to further pages that the reader, whether a machien or a human, can follow.

*** Ruby and ATOM
A number of ATOM and RSS libraries exist for Ruby. For the purpose of this course we use the Feedzirra library (https://www.ruby-toolbox.com/projects/feedzirra, documentation http://rubydoc.info/gems/feedzirra/0.2.1/frames). Feedzirra is a library building on the Nokogiri XML library to handle a number of feed formats.

#+BEGIN_EXAMPLE
sudo gem1.9 install feedzirra
#+END_EXAMPLE

#+BEGIN_SRC Ruby
require 'feedzirra'

# fetching a single feed
feed = Feedzirra::Feed.fetch_and_parse("http://ilovemyburger.blogspot.com/feeds/posts/default")
#"the quest for the best burger in Luxembourg"
feed.entries.each { |e| puts e.title}
#Outputs a lot of titles

entry_urls = feed.entries.collect { |e| e.url}
#Returns list of URLs
entry_urls = feed.entries.collect { |e| e.title.sanitized}
#Returns list of sanitized URLs
#+END_SRC

The library also permits to refetch the Feed with only updated entries:
#+BEGIN_SRC Ruby
updated_feed = Feedzirra::Feed.update(feed)
#+END_SRC


*** Excursion: Clojure, Rome and ~clj-rome~
"ROME is a set of RSS and Atom Utilities for Java that is open source under the Apache 2.0 license" (https://rometools.jira.com/wiki/display/ROME/Home). It is one of the most popular libraries for handling of (not only) ATOM in the Java world. ~clj-rome~ (https://clojars.org/clj-rome / https://github.com/ngrunwald/clj-rome) is a Clojure wrapper to the ROME library:

#+BEGIN_EXAMPLE
user=> (ns b5 
  #_=> (:require [clj-rome.reader :as rr]))
nil
b5=> (def feed (rr/build-feed "http://planet.clojure.in/atom.xml"))
#'b5/feed
b5=> (keys feed)
(:foreign-markup :published-date :entries :preserving-wire-feed? :copyright :link :contributors :author :supported-feed-types :feed-type :image :language :title :uri :categories :original :modules :interface :links :encoding :authors :title-ex :description :description-ex)
b5=> (count (:entries feed))
40
b5=> (map #(:title %) (:entries feed))
("Presentation: Distributed Apps: The Joys of Testing and Debugging" "Rich Hickey - Podcast Episode 019" "\"Concretely, a Graph is just a Clojure map of functions that can depend on the outputs of other...\"" "Google Common Lisp Style Guide" "Clojure/ClojureScript: One Language to Rule the Web" "No such pipe, or this pipe has been deleted" "codeq" "Writing Datomic in Clojure" "Announcing a new Clojure documentation project" "Stuart Sierra - Podcast Episode 018" "Clojure: Refactoring From Thread Last (-&gt;&gt;) To Thread First (-&gt;)" "Versatile into" "Top 20 Web Frameworks for the JVM" "Replacing Common Code With clojure.set Function Calls" "Clojure: Stages of Enlightenment." "Clojure Gazette 1.23" "Memobot" "All ideas are old ideas" "Announcing Langohr documentation guides" "Creating a glow effect" "clojure: lein tar" "Applying DRY to Editing" "Jay Fields' Thoughts: Clojure: Avoiding Anonymous Functions" "Does Scala as a FP Language Suffer From Its OO Syntax?" "No such pipe, or this pipe has been deleted" "Clojure: Avoiding Anonymous Functions" "HalBuilder 2.0.1 Progress" "More Core.logic" "Prismatic's \"Graph\" at Strange Loop" "Clojure Koans" "Image filtering" "Configuration Files in Clojure" "Functional thinking: Tons of transformations" "Functional thinking: Tons of transformations" "A Crash Course on CTCO" "Ecosystems Are Overrated" "I tried using Twitter Bootstrap this morning. Really nice way to support mobile devices." "Clojure Macro: defn-curried" "Clojure Gazette 1.22" "Some core.logic graph code")
b5=> (first (:entries feed))
{:enclosures [], :foreign-markup [], :wire-entry nil, :published-date nil, :link "http://www.infoq.com/presentations/Clojure-Stack-Trace", :contributors [], :author "Clojure at InfoQ", :title "Presentation: Distributed Apps: The Joys of Testing and Debugging", :uri "http://www.infoq.com/presentations/Clojure-Stack-Trace", :updated-date #inst "2012-10-12T22:40:00.000-00:00", :categories [], :modules [{:subject nil, :creator "Clojure at InfoQ", :date nil, :identifier nil, :formats [], :subjects [], :creators ["Clojure at InfoQ"], :types [], :contributors [], :coverages [], :contributor nil, :language nil, :title nil, :uri "http://purl.org/dc/elements/1.1/", :identifiers [], :rights nil, :rights-list [], :coverage nil, :type nil, :interface com.sun.syndication.feed.module.DCModule, :sources [], :dates [], :format nil, :publishers [], :relations [], :descriptions [], :languages [], :source nil, :relation nil, :titles [], :publisher nil, :description nil}], :interface com.sun.syndication.feed.synd.SyndEntry, :links [{:href "http://www.infoq.com/presentations/Clojure-Stack-Trace", :length 0, :title nil, :type nil, :rel "alternate", :hreflang nil}], :authors [{:name "Clojure at InfoQ", :uri "http://pipes.yahoo.com/pipes/pipe.info?_id=be83c0b5b0d92b259682cb8021e14d2a", :email nil, :modules []}], :title-ex {:type "html", :interface com.sun.syndication.feed.synd.SyndContent, :mode nil, :value "Presentation: Distributed Apps: The Joys of Testing and Debugging"}, :description nil, :contents [{:type "html", :interface com.sun.syndication.feed.synd.SyndContent, :mode nil, :value "Chris Houser discusses stack traces in Clojure and introduces a library for investigating activity across multiple threads and servers, plus a technique for reproducing race conditions. <i>By Chris Houser</i>"}]}
b5=> 
#+END_EXAMPLE

In these examples Clojure returns as usual a map that can be manipulated with the usual higher-order functions. ~:entries~ then contains a sequence of maps with the data for the individual entries.

**  Ruby Libraries for client-side RESTful web services
Ruby comes prepackaged with most libraries that are needed for running client-side RESTful webservices. The main involved packages are ~net/http~ and ~uri~, the latter potentially replaced by the ~addressable~ gem. Of these ~net/http~ and ~uri~ are by far the most commonly used libraries.

#+BEGIN_SRC Ruby
require 'net/http'
resp = Net::HTTP.get_response(URI("http://www.dradio.de/"))
#<Net::HTTPOK 200 OK readbody=true>
resp.code
#"200"
resp.body
#A lot of HTML
#+END_SRC

The library offers a number of convenience functions such as ~Net::HTTP.get_print~ (directly outputs the result to stdout) and ~Net::HTTP.get~ (returns the result as a string). For most control it is advisable to inspect the result, though.

The library has support for the other HTTP methods just as well:

- ~head~
- ~post~ and ~post_form~
- ~delete~

Sending ~PUT~ is a bit more complicated:

#+BEGIN_SRC Ruby
require 'net/http'

port = 8080
host = "www.example.com"
path = "/example/path"

req = Net::HTTP::Put.new(path, initheader = { 'Content-Type' => 'text/plain'})
req.body = "some text"
response = Net::HTTP.new(host, port).start {|http| http.request(req) }
#+END_SRC

The same logic can if needed also be used for all other HTTP methods.

All methods in their full form can take http headers:

#+BEGIN_SRC Ruby
require 'net/http'

req = Net::HTTP::Get.new("/", initheader = {"Accept-Language" => "de"})
resp = Net::HTTP.new("www.google.com", 80).start { |http| http.request(req)}
#Returns a 302 with a redirect to www.google.de
#+END_SRC

The library also has full proxy support.

** Libraries for RESTful web services for Java and Clojure

Session <2012-10-20 Sat>
- Popular JVM libraries for RESTful web services
- Client-side programming
  - Apache HttpComponents
  - clj-http as wrapper for HttpComponents
- Programming popular RESTful Web-Service Interfaces by  Google and Amazon in Clojure

RESTful web services are easy to use with most modern http libraries. For client-side Clojure the most common solution is ~clj-http~ (https://clojars.org/clj-http / https://github.com/dakrone/clj-http/) which in turn is based on the poplular Apache HttpComponents libraries.

Using ~clj-http~ is straightforward:

#+BEGIN_SRC clojure
(ns b5
  (:require [clj-http.client :as client]))
(client/get "http://www.dradio.de")
#+END_SRC

The return value comes as a standard Clojure map:

#+BEGIN_SRC clojure
{
:cookies {"NSC_esbejp_esbejp" {:discard true, :path "/", :value "ffffffffda4d535d45525d5f4f58455e445a4a423660", :version 0}}, :trace-redirects ["http://www.dradio.de"], :request-time 8894, :status 200, 
[...]
}
#+END_SRC

~clj-http~ supports all standard http operations.

In combination with URITemplates it is possible to run gets:

#+BEGIN_SRC clojure
(use 'uritemplate-clj.core)
(def google-template "http://www.google.com//#hl={language}&q={query}")
(map #(:status (client/get (uritemplate google-template %)))
[{"language" "de", "query" "restful web services"}, {"language" "de", "query" "uritemplate"}])
#+END_SRC

** Web Services the Google way
Session <2013-11-08 Fri>

Google offers a elegant, well-documented and powerful RESTful interfaces to its services. We will use it here to illustrate key RESTful principles in practice. This means no endorsement of any kind either by or for Google, with which the author has no affiliation.

The web service we are specifically using here is the Calendar API. We will see how to read, create, update and delete entries in a Google calendar.

*** Account and authentication
In a first stage you need to create a test account that is associated ot an email address (not necessarily a GMail account, though), obviously coupled to a password. With this we can look into the Google Console at https://code.google.com/apis/console:

#+CAPTION: Google API console
[[./img/google_console.png]]

After agreeing to various terms of use and activating the Calendar API
a user is free to use the service. Finally you can access the API key, a long machine generated unique identifier. Then you can authorize API Access that (amongst others) defines a product name, e.g. worms_calendar. Details of that process are described in https://developers.google.com/google-apps/calendar/firstapp and https://developers.google.com/google-apps/calendar/auth.

Authentication APIs are defined in https://developers.google.com/accounts/docs/GettingStarted#OAuth and https://developers.google.com/console/help/?hl=de#UsingKeys. You can interactively test it out using https://developers.google.com/oauthplayground/?hl=de. This way you can also access the relevant access tokens.

#+BEGIN_EXAMPLE
curl -H "Authorization: OAuth ya29.AHES6ZTUrYlO37e8qKFpKVPsCd-4Vd52sFtpR3MSeYB9Php1DZEr" https://www.googleapis.com/calendar/v3/users/me/calendarList
#+END_EXAMPLE

#+BEGIN_SRC clojure
(client/get "https://www.googleapis.com/calendar/v3/users/me/calendarList" {:headers {"Authorization" "OAuth ya29.AHES6ZTUrYlO37e8qKFpKVPsCd-4Vd52sFtpR3MSeYB9Php1DZEr"}})
#+END_SRC

returns a map. The body is encoded in JSON that we can parse with
Cheshire.

The same in Ruby:

#+BEGIN_SRC ruby
require 'net/http'
require 'json'

oauth_access_token = "ya29.AHES6ZSut6nn_NOLgfrnOJ2HueUGgyO0iE5pLPH7Cco6nw"

req = Net::HTTP::Get.new("/calendar/v3/users/me/calendarList", initheader = {"Authorization" => "OAuth #{oauth_access_token}"})
http = Net::HTTP.new("www.googleapis.com", 443)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
resp = http.request(req)

if resp.code == "200" then
  calendar_list = JSON::parse(resp.body)
  calendar_list["items"].each { |item| puts item["summary"]}
  #Web Services
  #Privat
else
  raise "Habe den Code #{resp.code} vom Server erhalten"
end
#+END_SRC

*** Accessing the API
I assume that we've obtained via OAuth2, e.g. using the OAuth 2.0 Playground, a valid access token.

#+BEGIN_SRC clojure
(def calender-list (client/get "https://www.googleapis.com/calendar/v3/users/me/calendarList" {:headers {"Authorization" "OAuth ya29.AHES6ZTUrYlO37e8qKFpKVPsCd-4Vd52sFtpR3MSeYB9Php1DZEr"}}))
(cheshire.core/parse-string (:body calender-list))
-->
{"kind" "calendar#calendarList", "etag" "\"940AbKLY6Usoo_WM4FY1utLF0hE/e3lCLkYVmdQwpp-Hfz7EeWMNxPA\"", "items" [{"defaultReminders" [{"method" "popup", "minutes" 30}], "foregroundColor" "#000000", "summary" "Web Services", "kind" "calendar#calendarListEntry", "etag" "\"940AbKLY6Usoo_WM4FY1utLF0hE/rr4G0y99XbqGdzSe2AOgZd0x12s\"", "backgroundColor" "#d06b64", "location" "Worms", "timeZone" "Europe/Berlin", "accessRole" "owner", "id" "XXXXX@googlemail.com", "colorId" "2"} {"foregroundColor" "#000000", "summary" "Privat", "kind" "calendar#calendarListEntry", "etag" "\"940AbKLY6Usoo_WM4FY1utLF0hE/16xw2sMaLL8vMyKzEGcRcZFPZBE\"", "backgroundColor" "#f691b2", "location" "Worms", "timeZone" "Europe/Berlin", "accessRole" "owner", "id" "u2nkrgh7m4hqvofv2nfn9jgnb8@group.calendar.google.com", "description" "Privater Kalender", "colorId" "22"}]}
#+END_SRC

or in Ruby

#+BEGIN_SRC clojure
#...
calendar_list = JSON::parse(resp.body)
puts calendar_list
#+END_SRC

We can then process the return value using standard Clojure operations:
#+BEGIN_SRC clojure
b5> (map #(get % "id")  (get (cheshire.core/parse-string (:body (client/get "https://www.googleapis.com/calendar/v3/users/me/calendarList" {:headers {"Authorization" "OAuth ya29.AHES6ZTn3crVvDHPVBldT2yXaec1hJqk9dsFeEW_oYs"}})              )) "items"))
("XXXXX@googlemail.com" "u2nkrgh7m4hqvofv2nfn9jgnb8@group.calendar.google.com")
b5> 
#+END_SRC

or in Ruby

#+BEGIN_SRC Ruby
req = Net::HTTP::Get.new("/calendar/v3/users/me/calendarList", initheader = {"Authorization" => "OAuth ya29.AHES6ZQpWRLZV_4MpKdILjJuNv7sqeF1xOn4MwQDwxBuZbnTsJVk"})
http = Net::HTTP.new("www.googleapis.com", 443)
http.use_ssl = true
resp = http.request(req)

calendar_list = JSON::parse(resp.body)
calendar_list["items"].collect { |item| item["id"] }
#["XXXXX@googlemail.com", "u2nkrgh7m4hqvofv2nfn9jgnb8@group.calendar.google.com"]
#+END_SRC


This information can now be used to attack individual calendars and e.g. read all events stored in them.

Details of the calendar API are documented under https://developers.google.com/google-apps/calendar/

#+BEGIN_SRC clojure
(client/get "https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events" {:headers {"Authorization" "OAuth ya29.AHES6ZTn3crVvDHPVBldT2yXaec1hJqk9dsFeEW_oYs"}})

(map #(get % "summary") (get (cheshire.core/parse-string (:body (client/get "https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events" {:headers {"Authorization" "OAuth ya29.AHES6ZQ_OFaA6RX0VqilLznX6DJOKGBvCChoFB_Mff8"}}))) "items"))
-->
("Web 3" "Schwimmen gehen" "Essen" "Brief schreiben" "Spazierengehen#" "Essen gehen" "Essen gehen" "Web 3" "test" "test" "ZERRIK URA" "ZERRIK URA" "Test" "Gelibesuchen" "Gelibesuchen" "B5 Nachholtermin" "Mensaessen" "Besprechung" "Test in B5" "Pratikum" "Pratikum heute Nachmittag" "Schwimmen" "Schwimmen" "Essen" "Schlafen" "Test0815" "Test0815" "Test0815" "Test0815" "Test0815" "Test0815" "web3" "Test0815" "Test0815" "Test0815" "Test0815" "Fahrrad" "Test0815" "Fahrrad" "Editierter Titel" "Vorlesung im O206" "Huepfen" "H��rdenlauf" "zweiter eintrag" "Test0815" "Test0815" "web3" "Test Eintrag in Web3" "Neuer Termin" "XYZ&" "New4r" "Test0815" "Wir gehen huepfen" "test")
#+END_SRC

or with curl:
#+BEGIN_EXAMPLE
curl -v --header "Authorization: OAuth ya29.AHES6ZSut6nn_NOLgfrnOJ2HueUGgyO0iE5pLPH7Cco6nw" https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events
#+END_EXAMPLE

or in Ruby:
#+BEGIN_SRC clojure
require 'addressable/template'
require 'rest_client' #new library

calendar_name = "XXXXX@googlemail.com"
template =
Addressable::Template.new("https://www.googleapis.com/calendar/v3/calendars/{+calendar_name}/events")
uri  = template.expand ({"calendar_name" => calendar_name})
puts uri

oauth_access_token = "ya29.AHES6ZQpnqFNFQg2u5Y7ZmL4xbJ0uiY15EBWrFf7CXr92Q"
resp = RestClient.get uri.to_s, {"Authorization" => "OAuth #{oauth_access_token}"}
if resp.code == 200 then
  puts resp.body
else
  raise "Habe den Code #{resp.code} zurueckbekommen"
end
#+END_SRC

The RestClient gem http://rubydoc.info/gems/rest-client/1.6.7/frames is an abstraction on top of the ~net/http~
standard library that offers a much more friendly alternative to the
relatively low-level operations of ~net/http~:

#+BEGIN_EXAMPLE
require 'rest_client'

RestClient.get 'http://example.com/resource'

RestClient.get 'http://example.com/resource', {:params => {:id => 50, 'foo' => 'bar'}}

RestClient.get 'https://user:password@example.com/private/resource', {:accept => :json}

RestClient.post 'http://example.com/resource', :param1 => 'one', :nested => { :param2 => 'two' }

RestClient.post "http://example.com/resource", { 'x' => 1 }.to_json, :content_type => :json, :accept => :json

RestClient.delete 'http://example.com/resource'

#taken from http://rubydoc.info/gems/rest-client/1.6.7/frames
#+END_EXAMPLE

The same mechanism can then also be used to add new events by sending a suitable JSON request:

#+BEGIN_EXAMPLE
{"start":{"dateTime":"2012-10-20T10:00:00.000-01:00"},"summary":"B5 Lecture today","location":"A126","attendees":["abc@xy.de"],"end":{"dateTime":"2012-10-20T15:00:00.000-01:00"}}
#+END_EXAMPLE

In Clojure the corresponding code looks like this:

#+BEGIN_SRC clojure
(def event (cheshire.core/generate-string {"summary" "B5 Lecture today", "location" "A126", "start"  {"dateTime" "2012-10-20T10:00:00.000-01:00"}, "end" {"dateTime" "2012-10-20T15:00:00.000-01:00"}, "attendees" ["abc@xy.de"]}))

(client/post "https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events" {:headers {"Authorization" "OAuth ya29.AHES6ZQ_OFaA6RX0VqilLznX6DJOKGBvCChoFB_Mff8"} :content-type :json :body event}) 
#+END_SRC

or in Ruby:

#+BEGIN_SRC Ruby
require 'json'
require 'rest_client'
event = {"summary" => "B5 Lecture today", "location" => "A126",
"start" => {"dateTime" => "2013-11-08T10:00:00.000-01:00"}, "end" =>
{"dateTime" => "2013-11-08T15:00:00.000-01:00"}, "attendees" =>
["abc@xy.de"]}

response = RestClient.post "https://www.googleapis.com/calendar/v3/calendars/XXXXXX@googlemail.com/events", event.to_json, {"Authorization" => "OAuth ya29.AHES6ZT5tdB-B3QCVSBiUuRERt7QMsLu0R0x0OdkpT363A", "Content-Type" => "application/json"}
JSON::parse(response.body)["id"]
#--> "61t660boqd8cmgsboeqi8792dg"
#+END_SRC



If successful the method returns a 200 JSON struture repeating the full information about the created entry. Most importantly, it also returns the event id that can afterwards be used to modify the created entry.

#+BEGIN_EXAMPLE
(get (cheshire.core/parse-string (:body (client/post "https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events" {:headers {"Authorization" "OAuth ya29.AHES6ZQ_OFaA6RX0VqilLznX6DJOKGBvCChoFB_Mff8"} :content-type :json :body event}))) "id")
-->
"74bvi6025o76q1ffpalst8ih60"
#+END_EXAMPLE

With this information we can update (= ~PUT~) the event:
#+BEGIN_EXAMPLE
(def modified-event (cheshire.core/generate-string {"summary" "B5 Lecture today, prolonged", "location" "A126", "start"  {"dateTime" "2012-10-20T10:00:00.000-01:00"}, "end" {"dateTime" "2012-10-20T16:00:00.000-01:00"}, "attendees" ["abc@xy.de"]}))
(client/put "https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events/74bvi6025o76q1ffpalst8ih60" {:headers {"Authorization" "OAuth ya29.AHES6ZQ_OFaA6RX0VqilLznX6DJOKGBvCChoFB_Mff8"} :content-type :json :body modified-event})
#+END_EXAMPLE

or in Ruby:

#+BEGIN_SRC Ruby
require 'json'
require 'rest_client'
require 'addressable/template'

event_new = {"summary" => "B5 Lecture tomorrow", "location" => "O103", "start" => {"dateTime" => "2013-11-08T10:00:00.000-01:00"}, "end" => {"dateTime" => "2013-11-08T15:00:00.000-01:00"}, "attendees" => ["abc@xy.de"]}


template = Addressable::Template.new "https://www.googleapis.com/calendar/v3/calendars/{+calendar_id}/events/{event_id}"
uri = template.expand({ "calendar_id" => "XXXXX@googlemail.com", "event_id" => "61t660boqd8cmgsboeqi8792dg"})
oauth_access_code = "ya29.AHES6ZTDhXSjOULxdJpo46lfewJ8zNg7RxXLLUM6yrjJIeIISROc"
response = RestClient.put uri.to_s, event_new.to_json, :content_type => :json, "Authorization" => "OAuth #{oauth_access_code}"
puts response.code
#+END_SRC

or even delete it again
#+BEGIN_EXAMPLE
(client/delete "https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events/74bvi6025o76q1ffpalst8ih60" {:headers {"Authorization" "OAuth ya29.AHES6ZQ_OFaA6RX0VqilLznX6DJOKGBvCChoFB_Mff8"}})
-->
{:trace-redirects ["https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events/74bvi6025o76q1ffpalst8ih60"], :request-time 586, :status 204, :headers {"cache-control" "no-cache, no-store, max-age=0, must-revalidate", "pragma" "no-cache", "expires" "Fri, 01 Jan 1990 00:00:00 GMT", "date" "Fri, 19 Oct 2012 17:27:54 GMT", "etag" "\"xuTtQAt8DDsZ3NJgXaKj-AnoGow/W6k8nbDP-T9StSHXQg5D9u2ieE8\"", "server" "GSE", "connection" "close"}, :body nil}
#+END_EXAMPLE

or in Ruby:
#+BEGIN_SRC Ruby
require 'rest_client'
response = RestClient.delete 'https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events/qeg945oge19n8naea4l2r8unvs', "Authorization" => "OAuth ya29.AHES6ZTDhXSjOULxdJpo46lfewJ8zNg7RxXLLUM6yrjJIeIISROc"
#+END_SRC


** OAuth2
The OAuth 2.0 Authorization Framework RFC 6750 (http://tools.ietf.org/html/rfc6750) becomes more and more the default standard for RESTful authorization. It is supported by most of the major players including Google, Facebook and Github (most of those that remain use the predecessor standard OAuth 1.0):

#+BEGIN_EXAMPLE
     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+
(Source: RFC 6750)
#+END_EXAMPLE

For the purpose of these tests we use a local callback function under http://localhost:3000/api/facebook-callback.

#+BEGIN_EXAMPLE
$ curl -v -XGET "https://www.facebook.com/dialog/oauth?client_id=XXX&redirect_uri=http://localhost:3000/api/facebook-callback"
--> redirect to URI, gives code
$curl -v -XGET "https://graph.facebook.com/oauth/access_token?client_id=XXX&client_secret=YYYYYYY&redirect_uri=http://localhost:3000/api/facebook-callback&code=AQA5hjdHIKzV6TsMe-sxFqV8A_xI0pu0I-Xb8AIZusVq9Zgt472OGrjW87FXzlMIk_o6TSNMFCear7gpBsHrRSxGOJCegZm65vEv3Mul7N32m5bVem_tB7Nsz8hFhjjoD5yL76pEB--KaZptJvHyEmtR2O7ROM8i0WZj4ERtp7YB3AFhoQAt-Hacp_r9AB4pFmMGgtiwlUs4q45DbATabgTG"
[...]
access_token=AAADRXLVkRpIBAOVAWRhWUQzITBsLbZCkRUgxxpakh8YJIo1jOiqw5nWp82SSiGRo41TLFarO6StOROjbCBf9RHZBQJCzFaBCRxwsjIYwZDZD&expires=5182940
$ curl -XGET "https://graph.facebook.com/me?access_token=AAADRXLVkRpIBAOVAWRhWUQzITBsLbZCkRUgxxpakh8YJIo1jOiqw5nWp82SSiGRo41TLFarO6StOROjbCBf9RHZBQJCzFaBCRxwsjIYwZDZD"
#+END_EXAMPLE

or for Google OAuth:

#+BEGIN_EXAMPLE
$curl -v
"https://accounts.google.com/o/oauth2/auth?client_id=XXXXXX&redirect_uri=http://localhost:3000/api/google-callback&response_type=code&scope=https://www.googleapis.com/auth/calendar"
--> Asks user for authorization, gives code
--> Now how to handle callback?
#+END_EXAMPLE

For Ruby Google provides a standard library with OAuth implemented: https://github.com/google/google-api-ruby-client

** Assignment

1. Develop a command line application in Clojure that takes as parameter an access token, a mode (create, update, delete) and 
   - for create: a title, a start and an end date, and a list of participants as email addresses
   - for update: an event id, a title, a start and an end date, and a list of participants as email addresses
   - for delete: an event id

   The application inserts / modifies / deletes the event in the Calendar. To simpliy things you can assume that you always get all parameters in the sequence mentioned above on the command line, e.g.:

#+BEGIN_EXAMPLE
ruby google_calendar.rb ACCESS-KEY MODE PARAMETER1 PARAMETER2...
#+END_EXAMPLE

2. Enhance the command line application so that it lists all of today's events

Work in teams of two, but hand in the results individually via the project's Moodle page. Indicate in the comments your team partner.


* Server-side REST 
Session <2013-11-09 Sat>
- Server-side programming 
  - Sinatra, a Ruby web application framework

** Sinatra
Prezy on Sinatra: http://prezi.com/nwvj2wrstfro/?utm_campaign=share&utm_medium=copy

** The Giant Global Graph: Facebook

The development uses a Facebook account specifically created for this purpose with the login / email XXXXX@googlemail.com and the username Web Worms.

http://www.facebook.com/web.worms.7?sk=timeline

Facebook has a well-known set of objects associated to an entity (person or company). This person can have certain properties such as  name, email address, age etc, can own other objects such as photos and most importantly be linked to other entities ("friends") or objects in general ("likes" or similar). "All of the objects in the Facebook social graph are connected to each other via relationships. Bret Taylor is a fan of the Coca-Cola page, and Bret Taylor and Arjun Banker are friends" (https://developers.facebook.com/docs/reference/api/).

In general Facebook constitute a monstrous directed graph in which each entity (node) and relationship can carry properties.

Some properties such as ~id~, ~name~, ~first_name~, ~last_name~, ~link~, ~username~, ~gender~ and ~locale~ are more equal than others in that they are always present:
#+BEGIN_EXAMPLE
{
   "id": "220439",
   "name": "Bret Taylor",
   "first_name": "Bret",
   "last_name": "Taylor",
   "link": "http://www.facebook.com/btaylor",
   "username": "btaylor",
   "gender": "male",
   "locale": "en_US"
}
#+END_EXAMPLE


It is simple to access public information in machine readable format, concretely JSON, for any user:
#+BEGIN_EXAMPLE
$ curl https://graph.facebook.com/web.worms.7
{"id":"100004654151051","name":"Web Worms","first_name":"Web","last_name":"Worms","link":"http:\/\/www.facebook.com\/web.worms.7","username":"web.worms.7","gender":"female","locale":"de_DE"}
#+END_EXAMPLE

In fact, all (or almost all) of the Facebook functionality is exposed via RESTful webservices. However, only some of the information is publicly accessible, for the remainder we need a login. Given the right permissions you can then get an access-token to see much more information. However, how to integrate a login programmatically via OAuth is the subject of another session. 

For now we can use the Facebook Graph API tool allows to test the environment: http://developers.facebook.com/tools/explorer?method=GET&path=me%3Ffields%3Dlikes.offset%285000%29.limit%285000%29

[[img/facebook_permissions.png]]

[[img/facebook_graph_api.png]]


Via the Graph API tool you can easily ~GET~ information, ~POST~ new entries and in general to everything you can do otherwise with the client.

** Assignment
Based on the first steps in https://github.com/mwkuster/budabe-graph:

- Define a FQL query to find a given user and all its friends via the Facebook Graph API Explorer (FQL is documented under https://developers.facebook.com/docs/reference/fql/)
- Extend budabe-graph.core both for the implementation and tests to handle connections between objects (possibly taking into account the experience with the Facebook query)

** ~budabe-graph~
Session: <2012-11-17 Sat>

Before going further into Facebook, let us do our first own RESTful web application called ~budabe-graph~ that allows to create, update and get information on persons and their links between them.

The two key libraries in this space are ~ring~ and ~compojure~.


#+BEGIN_SRC clojure
(defproject budabe-graph "0.1.0-SNAPSHOT"
  :description "A super-simple social graph application"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.4.0"]
                 [compojure "1.1.3"]
                 [ring "1.1.6"]
                 [cheshire "4.0.4"]
                 [clojurewerkz/neocons "1.1.0-beta1"]])
#+END_SRC

~ring~ (https://clojars.org/ring) self-describes itself as a "Clojure web applications library". Ring offers a number of functionalities, but as its core it defines a set of standards for Clojure structure, low-level handling HTTP requests as well as a means to define handlers for those requests. ~compojure~ offers a means to define routes to map concrete URIs and HTTP methods on these handlers. 

~compojure~ in turn ensures the rouging of elements:
#+BEGIN_SRC clojure
(defroutes main-routes
  (GET "/" [] (json/generate-string (list-users)))
  (POST "/"  request (create-user-handler  (:body request)))
  (PUT "/"  request (update-user-handler  (:body request)))
  (GET "/:username" [username] (get-user-by-username username))
  (route/not-found "Page not found"))
#+END_SRC

Then the RESTful interface can respond to the usual HTTP methods:

#+BEGIN_EXAMPLE
$ curl -v -XPOST -d '{"username": "johnsmith", "first_name" : "John", "last_name": "Smith", "gender" : "male", "locale": "US"}' --header "Content-Type: application/json" http://localhost:3000/
$  curl -v -XPOST -d '{"username": "janegreen", "first_name" : "Jane", "last_name": "Green", "gender" : "female", "locale": "US"}' --header "Content-Type: application/json" http://localhost:3000/
$  curl -v -XGET http://localhost:3000/

$ curl -v -XPUT -d '{"username": "johnsmith", "first_name" : "John", "last_name": "Brown", "gender" : "male", "locale": "US"}' --header "Content-Type: application/json" http://localhost:3000/johnsmith
#+END_EXAMPLE




** Creating a Facebook application
Session <2012-11-17 Sat>

In order to create a new application that integrates with Facebook, you have to be log  into Facebook and then go to https://developers.facebook.com/ to create a basic application. In a first stage you must register as an application developer, having to give unfortunately also a GSM number (you can delete it afterwards). After some more screens you can choose an application name, here WormsB5, to develop the application:

[[img/facebook_screenshot.png]]

In the end you get the real information:

#+BEGIN_EXAMPLE
WormsB5
App ID: 	YYYYY
App Secret: 	XXXX
#+END_EXAMPLE

In a permission screen you can request which permissions the application needs to work. In this case I have requested the same rights as a friend for a number of fields including email:

[[img/facebook_permission_tab.png]]

"As with any other OAuth-enabled app, to get started you’ll need to acquire an application ID and secret to use for authorization, opt into the developer community, and create an application" ({Russell:2011vv}, p. 272). For this purpose you need the App ID and the App Secret to log in. For this it needs

- the application ID
- the application secret
- a callback URL

that all need to be configure in the Facebook app centre.

A Facebook user wanting to use this application then needs to grant it access.

The overall flow is described in http://dragon.ak.fbcdn.net/cfs-ak-ash4/84991/914/165799420225798-/server-side-diagram.png

#+BEGIN_EXAMPLE
$curl "https://graph.facebook.com/oauth/access_token?client_id=XXX&grant_type=client_credentials&redirect_uri=http://localhost:8080/facebook-callback&code=AQBMSgT3RhBbZdpQ0tQo0vJURoYm4SV011MmG5RUfWTXg-LoNxJhUAZ2FxHFm_TAhf_nbhEN2_5fCP9fbla5s2HEDh1JWmMb8yy2aLMWUPwjiTNYoTtUV7FrumEYQ8SEhIuq8mshUbNaHULo2mo45eT_JNOGzWXvfNEuAMZDTdCfjg6gRUS4GqwadLNMzu46WT1BssHn2fSvKGid7kc55PCt&client_secret=YYYY"
#+END_EXAMPLE


** Assignment
Build on yesterday's assignment use your query to build up the network of a person (~https://graph.facebook.com/me~) and his / her friends and other connections (friends, likes...) in Neo4j. For this purpose either change or enhance the existing RESTful interface to ensure that the objects and connections that you have retrieved from Facebook is loaded as nodes and their relationships into Neo4j.

Work in teams of two, but hand in the results individually via the project's Moodle page. Indicate in the comments your team partner.

** Facebook and graphs
- Show implementation of assignment
- RDFa to embed information

# Write a ATOM publisher in Clojure using the ROME library that consumes at least two existing feeds, then uses Java interop to access SyndFeed (https://rometools.jira.com/wiki/display/ROME/Rome+v0.4+Tutorial%2C+Using+Rome+to+create+and+write+a+syndication+feed) to create a new aggregation feed based on the source feeds. Use ring to set up a server to publish the resulting feed. 

#   * SOAP-based Web Services and Service-oriented Architectures 
#   Session <2012-11-03 Sat>
#   - XML Schema
#     - Syntax
#     - Content models
#     - Choice and All
#   - Interface descriptions: WSDL
#
#   Session <2012-11-16 Fri>
#   - SOAP 
#   - Tools: soapUI
#   - Tools to check the data flow (e.g. tcpMon)
#   - Services: SOAs: heterogeneous, loosely-coupled architectures
#   - Concepts of semantic and organizational interoperability
#
#   * Programming SOAP-based Web Services
#   Session <2012-11-17 Sat> 
#   - Popular JVM libraries for SOAP-based services
#     - Apache Axis 2 and clj-soap (https://clojars.org/org.clojars.seancorfield/clj-soap)
#     - Jax-RPC 2.0 / JAX-WS 2.0 (http://www.artima.com/lejava/articles/threeminutes.html, http://stackoverflow.com/questions/2855292/scala-simple-webservice, https://gist.github.com/381129)
#   - Implementing clients for existing simple SOAP services in Clojure
#     - Generation of stubs
#     - Analysis of stubs
#   - Implementing simple SOAP services in Clojure




* Testing RESTful Web Services

TODO

* Neo4j: a RESTful Database
Session <2012-11-02 Fri>

*** What is Neo4j?
The Open Source database Neo4j (http://www.neo4j.org) is an example of the growing segment of NoSQL databases. It is a graph database that centres around two Topic Map {ISOIEC:2002uf} like concepts, nodes and relationships. Nodes and relationships have unique identifiers, but can have arbitrary properties besides. If Neo4j speaks of graphs, it is directed graphs that it thinks of, so each relationship must have a start and an end node. Otherwise, relationships are database objects just like nodes that can be created, updated and deleted, be queried and have properties just like nodes.

A graph database assumes that we want to model the world as a directed graph --- {Redmond:2012wd} uses the term "whiteboard-friendly modelling":

[[img/neo4j_graph.png]]

Installation of Neo4j is trivial:

1. Download the latest version from http://neo4j.org/download/
2. Unpack it to a suitable directory
3. ~cd~ to that directory and execute ~bin/neo4j start~ or the corresponding command under Windows
4. Check with http://localhost:7474/webadmin that the database is up

** Neo4j's admin interface
Neo4j’s admin interface also has one of the more innovative graph UIs that is currently available in an off-the-shelf database.


The graph we have just seen can be translated as is into Neo4j, using e.g. the +Node and +Relationship features of the Neo4j data browser that is part of the admin interface:

[[img/neo4j_databrowser.png]]

The node and its relationships can then also be visualized:

And finally queried:

#+BEGIN_EXAMPLE
START n = node(*)
WHERE has(n.name) and n.name = "B5"
RETURN n;

--> returns Node
#+END_EXAMPLE

Neo4j positions itself for enterprise use and seems to currently see significant uptake:

#+BEGIN_QUOTE
As a robust, scalable and high-performance database, Neo4j is suitable for full enterprise deployment or a subset of the full server can be used in lightweight projects.
It features:
- true ACID transactions
- high availability
. scales to billions of nodes and relationships
- high speed querying through traversals {Neojorg:2012tu}
#+END_QUOTE


** Neo4j's RESTful interface
Like many of the new developments in the NoSQL scene, Neo4j exposes a RESTful interface, though in this specific case Neo4j also has a powerful admin interface that gives access to many of its features, including its query language, Cypher. It is also possible to directly embed Neo4j in an application, though we will not look at this case here. 

Already our examples before have given some first impressions of Neo4j's RESTful web service interface:

#+BEGIN_EXAMPLE
A concrete node: http://localhost:7474/db/data/node/20991

A search for this node: http://localhost:7474/webadmin/#/data/search/20991/ 

A concrete relationship, "Node 1 part-of Node 3": http://localhost:7474/db/data/relationship/2

A search for this relationship: http://localhost:7474/webadmin/#/data/search/rels%3A3/

A query: http://localhost:7474/webadmin/#/data/search/START%20n%20%3D%20node(*)%0AWHERE%20has(n.name)%20and%20n.name%20%3D%20%22B5%22%0ARETURN%20n%3B/
#+END_EXAMPLE



Neo4j is well documented: http://docs.neo4j.org/chunked/milestone/rest-api.html. Like many other interfaces it uses JSON as data exchange format.

These URIs work also programmatically as expected and return a JSON representation of the given node, giving links to related objects:

#+BEGIN_EXAMPLE
$ curl -XGET http://localhost:7474/db/data/node/20991
-->

{
  "extensions" : {
  },
  "paged_traverse" : "http://localhost:7474/db/data/node/20991/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/20991/relationships/out",
  "traverse" : "http://localhost:7474/db/data/node/20991/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/20991/relationships/all/{-list|&|types}",
  "property" : "http://localhost:7474/db/data/node/20991/properties/{key}",
  "all_relationships" : "http://localhost:7474/db/data/node/20991/relationships/all",
  "self" : "http://localhost:7474/db/data/node/20991",
  "properties" : "http://localhost:7474/db/data/node/20991/properties",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/20991/relationships/out/{-list|&|types}",
  "incoming_relationships" : "http://localhost:7474/db/data/node/20991/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/20991/relationships/in/{-list|&|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/20991/relationships",
  "data" : {
    "name" : "B5",
    "type" : "Course"
  }
}
#+END_EXAMPLE

or for relationships:

#+BEGIN_EXAMPLE
$ curl -XGET http://localhost:7474/db/data/relationship/2
{
  "extensions" : {
  },
  "start" : "http://localhost:7474/db/data/node/1",
  "property" : "http://localhost:7474/db/data/relationship/2/properties/{key}",
  "self" : "http://localhost:7474/db/data/relationship/2",
  "properties" : "http://localhost:7474/db/data/relationship/2/properties",
  "type" : "part-of",
  "end" : "http://localhost:7474/db/data/node/3",
  "data" : {
    "link-text" : ":part-of:->xpointer(/TEI[1]/text[1]/group[1]/text[1]/body[1]/div[1]/sp[1]/ab[1]/text()[1])"
  }
}
#+END_EXAMPLE


In best REST-way the interface exposes links to further representations of related objects (outgoing_relationships, incoming_relationships and all_relationships).

Of course, there is not only ~GET~: With ~PUT~ you can update properties, though with a slight twist in that you must go against the list of http://localhost:7474/db/data/node/20991/properties: 
#+BEGIN_EXAMPLE
$  curl -v -XPUT -H "Accept: application/json" -H "Content-type: application/json"  -d '{"name": "B5-1"}' http://localhost:7474/db/data/node/20991/properties 
 About to connect() to localhost port 7474 (#0)
   Trying ::1...
 Connection refused
   Trying 127.0.0.1...
 connected
 Connected to localhost (127.0.0.1) port 7474 (#0)
> PUT /db/data/node/20991/properties HTTP/1.1
> User-Agent: curl/7.27.0
> Host: localhost:7474
> Accept: application/json
> Content-type: application/json
> Content-Length: 16
> 
 upload completely sent off: 16 out of 16 bytes
< HTTP/1.1 204 No Content
< Access-Control-Allow-Origin: *
< Server: Jetty(6.1.25)
< 
 Connection #0 to host localhost left intact
 Closing connection #0
$  curl -XGET http://localhost:7474/db/data/node/20991/properties
{
  "name" : "B5-1"
}
#+END_EXAMPLE

As we see in this example, this operation replaces the current properties completely

And there's still delete, first on the property level:
#+BEGIN_EXAMPLE
$ curl -v -XDELETE -H "Accept: application/json" http://localhost:7474/db/data/node/20991/properties 
 About to connect() to localhost port 7474 (#0)
   Trying ::1...
 Connection refused
   Trying 127.0.0.1...
 connected
 Connected to localhost (127.0.0.1) port 7474 (#0)
> DELETE /db/data/node/20991/properties HTTP/1.1
> User-Agent: curl/7.27.0
> Host: localhost:7474
> Accept: application/json
> 
< HTTP/1.1 204 No Content
< Access-Control-Allow-Origin: *
< Server: Jetty(6.1.25)
< 
 Connection #0 to host localhost left intact
 Closing connection #0
$  curl -XGET http://localhost:7474/db/data/node/20991/properties
$
#+END_EXAMPLE

We can ~PUT~ back new properties:
#+BEGIN_EXAMPLE
$ curl -v -XPUT -H "Accept: application/json" -H "Content-type: application/json"  -d '{"name": "New B5", "participants" : 30}'  http://localhost:7474/db/data/node/20991/properties
 About to connect() to localhost port 7474 (#0)
   Trying ::1...
 Connection refused
   Trying 127.0.0.1...
 connected
 Connected to localhost (127.0.0.1) port 7474 (#0)
> PUT /db/data/node/20991/properties HTTP/1.1
> User-Agent: curl/7.27.0
> Host: localhost:7474
> Accept: application/json
> Content-type: application/json
> Content-Length: 39
> 
 upload completely sent off: 39 out of 39 bytes
< HTTP/1.1 204 No Content
< Access-Control-Allow-Origin: *
< Server: Jetty(6.1.25)
< 
 Connection #0 to host localhost left intact
 Closing connection #0
$  curl -XGET http://localhost:7474/db/data/node/20991/properties{
  "participants" : 30,
  "name" : "New B5"
}
#+END_EXAMPLE

And also update individual properties:
#+BEGIN_EXAMPLE
$ curl -v -XPUT -H "Accept: application/json" -H "Content-type: application/json"  -d '"New B5-2"'  http://localhost:7474/db/data/node/20991/properties/name
 About to connect() to localhost port 7474 (#0)
   Trying ::1...
 Connection refused
   Trying 127.0.0.1...
 connected
 Connected to localhost (127.0.0.1) port 7474 (#0)
> PUT /db/data/node/20991/properties/name HTTP/1.1
> User-Agent: curl/7.27.0
> Host: localhost:7474
> Accept: application/json
> Content-type: application/json
> Content-Length: 10
> 
 upload completely sent off: 10 out of 10 bytes
< HTTP/1.1 204 No Content
< Access-Control-Allow-Origin: *
< Server: Jetty(6.1.25)
< 
 Connection #0 to host localhost left intact
 Closing connection #0
$  curl -XGET http://localhost:7474/db/data/node/20991/properties{
  "participants" : 30,
  "name" : "New B5-2"
}
#+END_EXAMPLE

Which is in itself a comment on the importance of good URI design.

And finally we can ~Post~ a new node complete with properties:
#+BEGIN_EXAMPLE
$ curl -v -XPOST -H "Accept: application/json" -H "Content-type: application/json"  -d '{"name": "That is it"}'  http://localhost:7474/db/data/node/
 About to connect() to localhost port 7474 (#0)
   Trying ::1...
 Connection refused
   Trying 127.0.0.1...
 connected
 Connected to localhost (127.0.0.1) port 7474 (#0)
> POST /db/data/node/ HTTP/1.1
> User-Agent: curl/7.27.0
> Host: localhost:7474
> Accept: application/json
> Content-type: application/json
> Content-Length: 22
> 
 upload completely sent off: 22 out of 22 bytes
< HTTP/1.1 201 Created
< Content-Length: 1152
< Location: http://localhost:7474/db/data/node/30876
< Content-Encoding: UTF-8
< Content-Type: application/json
< Access-Control-Allow-Origin: *
< Server: Jetty(6.1.25)
< 
{
  "extensions" : {
  },
  "paged_traverse" : "http://localhost:7474/db/data/node/30876/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/30876/relationships/out",
  "traverse" : "http://localhost:7474/db/data/node/30876/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/30876/relationships/all/{-list|&|types}",
  "property" : "http://localhost:7474/db/data/node/30876/properties/{key}",
  "all_relationships" : "http://localhost:7474/db/data/node/30876/relationships/all",
  "self" : "http://localhost:7474/db/data/node/30876",
  "properties" : "http://localhost:7474/db/data/node/30876/properties",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/30876/relationships/out/{-list|&|types}",
  "incoming_relationships" : "http://localhost:7474/db/data/node/30876/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/30876/relationships/in/{-list|&|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/30876/relationships",
  "data" : {
    "name" : "That is it"
  }
 Connection #0 to host localhost left intact
}* Closing connection #0
#+END_EXAMPLE

In the ~Location~ response header the node identifies itself with its URI, as it foreseen in for ~POST~s.

Finally, we can also ~DELETE~ the node again:
#+BEGIN_EXAMPLE
$  curl -v -XDELETE http://localhost:7474/db/data/node/30876
 About to connect() to localhost port 7474 (#0)
   Trying ::1...
 Connection refused
   Trying 127.0.0.1...
 connected
 Connected to localhost (127.0.0.1) port 7474 (#0)
> DELETE /db/data/node/30876 HTTP/1.1
> User-Agent: curl/7.27.0
> Host: localhost:7474
> Accept: */*
> 
< HTTP/1.1 204 No Content
< Access-Control-Allow-Origin: *
< Server: Jetty(6.1.25)
< 
 Connection #0 to host localhost left intact
 Closing connection #0
#+END_EXAMPLE

The next ~GET~ to this resource returns new a 404.

In general, Neo4j's  RESTful interface allows to 
- access nodes and relationships
- create, update and delete nodes and relationships
- traverse the graph by following outcoming and incoming relationships of a node by following links
- executing Cypher queries
- creating and modifying indexes

and more

Properties are typed and support largely "classical" atomic types: boolean, byte, int, short, long, float, double, char and String.

** Cypher
Cypher is the name of Neo4j's query language. It is fully specified in chapter 15 of Neo4j's user manual.

A Cypher query can find nodes and relationships, create, update  and delete them and extract parts of them.

** Neocons

With neocons {Klishin:uc} Neo4j has an intuitive Clojure interface that permits at the same time  to store, update and query the graph inside the database.

Dependencies are:

#+BEGIN_SRC clojure
(defproject b5 "0.3.0-SNAPSHOT"
  :dependencies [[org.clojure/clojure "1.4.0"]
                 [clojurewerkz/neocons "1.1.0-beta1"]])
#+END_SRC

Neocons is well documented with most tutorials available under http://clojureneo4j.info/

**** Initializing the connection
#+BEGIN_SRC clojure
(def ^:dynamic *connection-string* "http://localhost:7474/db/data/")

(clojurewerkz.neocons.rest/connect! *connection-string*)
#+END_SRC

Neocons can handle only one connection at a time, but that is sufficient for our needs.


**** Creating nodes and relationships
The ~create~ method unsurprisingly creates nodes:

#+BEGIN_SRC clojure
(clojurewerkz.neocons.rest.nodes/create {:name "Name" :prop1 "Some value"})
#+END_SRC

The method returns the node created, uniquely identified by its node number.

Similarly, 

#+BEGIN_SRC clojure
(clojurewerkz.neocons.rest.relationships/create fst-node snd-node :link-type {:prop1 "Some value" :prop2 "Some other value"})
#+END_SRC

creates a new relationship and return it.

**** Updating nodes and relationships
Updating properties of nodes works via an update function (like for the REST interface there is no update of nodes per se):

#+BEGIN_SRC clojure
For all properties of a node:
(clojurewerkz.neocons.rest.nodes/update (:id node-to-be-updated) {:prop1 "Some value" :prop2 "Some other value"})

For a single property:
(clojurewerkz.neocons.rest.nodes/set-property (:id node-to-be-updated) :prop1 "Some value")
#+END_SRC

and the same for relationships:

#+BEGIN_SRC clojure
(clojurewerkz.neocons.rest.relationships/update  (:id rel-to-be-updated) {:prop1 "Some value" :prop2 "Some other value"})

(clojurewerkz.neocons.rest.nodes/set-property (:id rel-to-be-updated) :prop1 "Some value")
#+END_SRC

**** Creating indexes

Like all databases Neo4j also supports indexes, typically on some properties. Creating and handling those indexes is a bit unusual, though, in that you have to ensure that individual entries are added to the index.

There are two types of indexes, one for nodes and one for relationships:

#+BEGIN_SRC clojure
(clojurewerkz.neocons.rest.nodes/create-index "name-of-node-index" {:unique true}))

(clojurewerkz.neocons.rest.relationships/create-index "name-of-relationship-index" {:unique true}))
#+END_SRC

The name is later referred to when adding individual entries to the index:

#+BEGIN_SRC clojure
(clojurewerkz.neocons.rest.nodes/add-to-index (:id node-to-be-indexed) "name-of-node-index" "name-of-property" value)

(clojurewerkz.neocons.rest.relationships/add-to-index  (:id rel-to-be-indexed) "name-of-relationship-index" property-as-keyword value))
#+END_SRC

**** Finding nodes and relationships
Assuming that we have an index "idx" created, we can use it to retrieve it again:

#+BEGIN_SRC clojure
;Find all nodes where name-of-property has value
(clojurewerkz.neocons.rest.nodes/find "idx" property-keyword value)

;Find the node (maximum one) where name-of-property has value
(clojurewerkz.neocons.rest.nodes/find-one "idx" property-keyword  value)
#+END_SRC

and the same for relationships:

#+BEGIN_SRC clojure
;Find all nodes where name-of-property has value
(clojurewerkz.neocons.rest.relationships/find "idx" property-keyword value)

;Find the node (maximum one) where name-of-property has value
(clojurewerkz.neocons.rest.relationships/find-one "idx" property-keyword  value)
#+END_SRC

In addition, we can run Cypher queries using:
#+BEGIN_SRC clojure

(clojurewerkz.neocons.rest.cypher/tquery "START n = node(*) WHERE has(n.name) and n.name = \"B5\" RETURN n;")
#+END_SRC

The result is a list of maps.

In addition, we can traverse the graph, but that we will not cover here.


*** Assignment
Read an aggregated ATOM feeds such as Planet Clojure using the clj-rome library. The feed contains pointers to various other feeds. Extract the feed, its entries and the references to the original feeds and build a graph in Neo4j that has

- a node for the aggregated feed
- a node for each feed entry
- a node for each source feed
- a link from the entry node to its aggregated feed
- a link from the entry node to its source feed

This graph also is a social graph of interactions between feeds in a given domain.

Work in teams of two, but hand in the results individually via the project's Moodle page. Indicate in the comments your team partner.


** Accessing RESTful storage
Session <2012-11-03 Sat>

EMC2 ATMOS self-describes itself as a 
#+BEGIN_QUOTE
Cloud storage platform that lets enterprises and service providers store, manage, and protect globally distributed, unstructured content at scale. Atmos provides the essential building blocks to implement a private, public, or hybrid cloud storage environment. (http://www.emc.com/storage/atmos/atmos.htm)
#+END_QUOTE

It is developed by EMC Corporation, currently accourding to wikipedia the "the largest provider of data storage platforms in the world" and mother company to companies such as VMware, Iomega and Documentum. ATMOS can be used both as a hardware and software stack. It is meant for very big storage systems up to many petabytes of size. It can be deployed both in a public and a private cloud. In this it directly competes with services such as Amazon's S3 (Simple Storage Service) service and in fact has the S3 API as one of its options.

The overall architecture of EMC ATMOS is described in one of the company's whitepapers,  http://belgium.emc.com/collateral/software/white-papers/h9505-emc-atmos-archit-wp.pdf. 

The reason to explain RESTful APIs for cloud storage  with EMC2 ATMOS is you can get a free developer account to test the API: https://community.emc.com/docs/DOC-10405. The API documentation is available via https://community.emc.com/docs/DOC-10404 (with links to various libraries implementing that interface) and https://community.emc.com/docs/DOC-14430 (for the documetnation itself).



*** Security
The Atmos Online Programmers Guide 2.01 specifies on p. 99 the details on how to handle security:

**** Calculate a hash of the core http request itself
Dependencies on 
#+BEGIN_EXAMPLE
[commons-codec/commons-codec "1.4"]
#+END_EXAMPLE

The overall formula to calculate a signature is:
#+BEGIN_EXAMPLE
HTTPRequestMethod + '\n' +
   ContentType + '\n' +
   Range + '\n' +
   Date + '\n' +
   CanonicalizedResource + '\n' +
   CanonicalizedEMCHeaders
#+END_EXAMPLE

where ~CanonicalizedResource~ is the path and query part of the request-URI, in lower-case and ~CanonicalizedEMCHeaders~ are EMC-specific HTTP headers, prepared according to a given algorithm.

**** Signing a request

The signature of the request is itself transmitted as a custom http header ~x-emc-signature~:

For a request like:
#+BEGIN_EXAMPLE
{"x-emc-uid" "33115732f3b7455d9d2344ddd235f4b9/user1", "content-type" "application/octet-stream", "x-emc-date" "Fri, 02 Nov 2012 14:15:19 GMT", "x-emc-useracl" "user1"}
#+END_EXAMPLE

with ~POST~ as method on https://api.atmosonline.com/rest/objects and a secret key of ~LJLuryj6zs8ste6Y3jTGQp71xq0=~ (these are the values for UID and secret key given as an example in the manual) the result is a signature is ~mIAtBPko+OFST0l0hKsgFxA3/4s=~:

#+BEGIN_SRC clojure
(s6.atmos/sign "LJLuryj6zs8ste6Y3jTGQp71xq0" "POST" "rest/objects" {"x-emc-uid" "33115732f3b7455d9d2344ddd235f4b9/user1", "content-type" "application/octet-stream", "x-emc-date" "Fri, 02 Nov 2012 14:15:19 GMT", "x-emc-useracl" "user1"})
--> "mIAtBPko+OFST0l0hKsgFxA3/4s="
#+END_SRC

giving the complete set of headers:

#+BEGIN_EXAMPLE
{"x-emc-signature" "mIAtBPko+OFST0l0hKsgFxA3/4s=", "x-emc-uid" "33115732f3b7455d9d2344ddd235f4b9/user1", "content-type" "application/octet-stream", "x-emc-date" "Fri, 02 Nov 2012 14:15:19 GMT", "x-emc-useracl" "user1"}
#+END_EXAMPLE

To prevent replay attacks ~x-emc-date~ must be recent (within 5 minutes of the server time), otherwise a request is rejected.

*** Creating an object
Objects are as usual created via ~POST~ requests:
#+BEGIN_EXAMPLE
curl -v -XPOST -d "ATMOS, here I come" --header "x-emc-uid: UID" --header "content-type: application/octet-stream" --header "x-emc-date: Fri, 02 Nov 2012 14:15:19 GMT" --header "x-emc-useracl: A60284312655ec6780c9" --header "x-emc-signature: 6WqDxVWWvbOC3ZQGGD+hkvK+8sk=" https://api.atmosonline.com/rest/objects
#+END_EXAMPLE

If successful, the request returns a ~201~ and contains amongst other information a location header that points to the new object:

#+BEGIN_EXAMPLE
location: /rest/objects/4ee696e4a41f549604f0b75398081305093d5f6d1950
#+END_EXAMPLE

Alternatively, objects can also be created in a "logical" namespace by ~POST~ing to ~/rest/namespace~ with a URI afterwards that is interpreted as a directory:

#+BEGIN_SRC clojure
(create-object-in-namespace UUID SECRET USERID "/results/res3.xml" (slurp "/tmp/res3.xml") "author=ABC,date=2012-11-02")
#+END_SRC

resulting in the object and its tag structure being created. However, again the API returns the object id in the location header to uniquely identify the resulting object:

#+BEGIN_EXAMPLE
location: /rest/objects/4ee696e4a31f549604f0b753961dcc0509435479c09f
#+END_EXAMPLE

*** Atmosfox
A Firefox plugin, Atmosfox, allows to navigate remote files in somewhat Norton-commander-style.

In the following screenshots we see the restults of the previous command, as shown in Atmosfox in object view:

[[img/atmosfox_files.png]]

[[img/atmosfox_author_date.png]]

and the same in namespace view:

[[img/atmosfox_namespace_view.png]]

*** Handling of Metadata

All objects have system metadata. They can also have user-defined metadata that is transmitted in the custom header ~x-emc-listable-meta~ and has the form ~tag_name1=value1,tag_name2=value2~. For metadata that is just stored, but not searchable there is yet another header called ~x-emc-meta~.

The general approach for accessing metadata is:

For system level metadata:

#+BEGIN_EXAMPLE
/rest/objects/<objectID>?metadata/system
or 
/rest/namespace/<pathname>?metadata/system
#+END_EXAMPLE

This gives for example:

#+BEGIN_SRC clojure
(get-system-metadata UUID SECRET-KEY "4ee696e4a31f549604f0b753961dcc0509435479c09f")
{:trace-redirects ["https://api.atmosonline.com/rest/objects/4ee696e4a31f549604f0b753961dcc0509435479c09f?metadata/system"], :request-time 2703, :status 200, :headers {"date" "Sat, 03 Nov 2012 07:20:11 GMT", "server" "Apache", "x-emc-policy" "_int", "x-emc-meta" "atime=2012-11-02T21:04:07Z, mtime=2012-11-02T21:04:07Z, ctime=2012-11-02T21:04:07Z, itime=2012-11-02T21:04:07Z, type=regular, uid=A60284312655ec6780c9, gid=apache, objectid=4ee696e4a31f549604f0b753961dcc0509435479c09f, objname=res3.xml, size=1957, nlink=1, policyname=default", "content-length" "0", "connection" "close", "content-type" "text/plain; charset=UTF-8"}, :body ""}
#+END_SRC 

By default all system-level metadata is returned. Using ~x-emc-tags~ it is possible to filter.

For user metadata the approach is quite the same:

#+BEGIN_EXAMPLE
/rest/objects/<objectID>?metadata/user
or 
/rest/namespace/<pathname>?metadata/user
#+END_EXAMPLE

giving for example:

#+BEGIN_SRC clojure
(get-user-metadata UUID SECRET-KEY "4ee696e4a31f549604f0b753961dcc0509435479c09f")
{:trace-redirects ["https://api.atmosonline.com/rest/objects/4ee696e4a31f549604f0b753961dcc0509435479c09f?metadata/user"], :request-time 1650, :status 200, :headers {"date" "Sat, 03 Nov 2012 07:21:15 GMT", "server" "Apache", "x-emc-policy" "_int", "x-emc-listable-meta" "author=ABC, date=2012-11-02", "content-length" "0", "connection" "close", "content-type" "text/plain; charset=UTF-8"}, :body ""}
#+END_SRC 

Again, it is possible to filter with ~x-emc-tags~.

*** Assignment
Continue yesterday's assignment, but devise namespaces to actually store the corresponding entries in the ATMOS developer acount (for a few examples). Have Neo4j store those references as content references.

* The Semantic Web
Sessions <2012-12-14 Fri> and <2012-12-15 Sat>
- What are Ontologies? Ontologies and Us
- Ontologies and Technology
  - Standards
    - RDF
    - RDF-S
    - OWL
    - SPARQL:
      http://data.gov.uk/sparql
      http://jena.apache.org/tutorials/sparql.html
      http://www.cambridgesemantics.com/semantic-university/sparql-by-example#%281%29
  - Object identity
  - Tools
    - Protégé
    - Semantic Stores
- Linked Open Data
- Semantic Web Services

http://data.gov.uk/sparql

cf. presentation stored in Moodle.

* Preparing the Practical Programming Projects
Sessions <2012-12-15 Sat>

cf. https://moodle.fh-worms.de/moodle/mod/page/view.php?id=17310

* Social media and the Semantic Web
Session <2013-01-04 Fri>

** Programming the Semantic Web

A large number of libraries exist for handling RDF including well-established Open Source Java libraries such as Sesame and Jena. For Clojure, Seabass (https://clojars.org/seabass) offers a small wrapper around the Jena library, making it easy to treat RDF in Clojure. Similar libraries exist for other platforms.

As dependencies you add:
#+BEGIN_SRC clojure
[xerces/xercesImpl "2.10.0"] ;; Direct download from Maven central
[seabass "2.0"]
#+END_SRC


This will also download the Jena libraries which do most of the work.

Once seabass is installed, using it is simple: 

You ~build~ a model, essentially a local database containing ~seabass.core~ triples you just load one or more files in one of the possible RDF serialzation formats (cf. below):
#+BEGIN_SRC clojure
(def model 
  (build ["src/s12/62007CJ0535.rdf" "RDF/XML"]
         ["src/s12/61960CC0002.ttl" "TTL"]))
#+END_SRC

In addition, you can also indicate URIs from which these files should be downloaded. You can also integrate data from external SPARQL endpoints using ~CONSTRUCT~ queries and the ~pull~ command:


#+BEGIN_SRC clojure
(def model 
  (build ["src/s12/62007CJ0535.rdf" "RDF/XML"]
         ["src/s12/61960CC0002.ttl" "TTL"]))

;;Query is
;;construct {?institution ?p ?o} {?institution a <http://dbpedia.org/class/yago/InstitutionsOfTheEuropeanUnion> . 
?institution ?p ?o
} LIMIT 10000")
(def model (build ["src/s12/62007CJ0535.rdf" "RDF/XML"]
         ["src/s12/61960CC0002.ttl" "TTL"]
         (pull "construct {?institution ?p ?o} {?institution a <http://dbpedia.org/class/yago/InstitutionsOfTheEuropeanUnion> . 
?institution ?p ?o
} LIMIT 10000" "http://dbpedia.org/sparql")))
 #+END_SRC

You can then execute queries against a model using the ~bounce~ function that takes the SPARQL ~SELECT~ query as a first parameter and a model as the second, e.g.:
#+BEGIN_SRC clojure
(bounce 
"PREFIX cdm: <http://publications.europa.eu/ontology/cdm#> 
select ?expr ?title ?lang
{?work cdm:resource_legal_id_celex \"62007CJ0535\"^^xsd:string .
 ?expr cdm:expression_belongs_to_work ?work .
 ?expr cdm:expression_title ?title .
 ?expr cdm:expression_uses_language ?lang .
 }" model)
#+END_SRC

The result is returnd as a Clojure map with all the results in the ~:data~ field:
#+BEGIN_SRC clojure
{:vars (:expr :title :lang), :data ({:lang "http://publications.europa.eu/resource/authority/language/FRA", :title "Arrêt de la Cour (deuxième chambre) du 14 octobre 2010. # Commission européenne contre République d'Autriche. # Manquement d’État - Directives 79/409/CEE et 92/43/CEE - Conservation des oiseaux sauvages - Désignation incorrecte et protection juridique insuffisante des zones de protection spéciale. # Affaire C-535/07.", :expr "http://anycellar.publications.europa.eu/resource/celex/62007CJ0535.FRA"}...)}
#+END_SRC

You can handle those results like any other Clojure map
#+BEGIN_SRC clojure
(filter #(= (:lang %) "http://publications.europa.eu/resource/authority/language/ENG")  (:data (get-titles-by-celex "61960CC0002")))
#+END_SRC

** RDF Serialization formats
Logically, all RDF is triples of subject, predicate and object, and indeed that is how it is often represtend internally inside triple stores. However, triples can be serialized and exchanged in a variety of different formats. Some of these such as Turtle are very close to the triple philosophy, others need more interpretation.

*** Turtle 
One of the simplest forms to encode semantic information is Turtle. Turtle essentially lists the triples. Individual triples are separated by dots (~.~), but in order to avoid long lists of full triples those triples that share the same subject and predicateonly list the different objects, separated by ~,~, whereas those only sharing the same subject are  compacted by using ~;~.

#+BEGIN_EXAMPLE
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix cdm: <http://publications.europa.eu/ontology/cdm#> .
@prefix cdm-annotation: <http://publications.europa.eu/ontology/annotation#> .
@base <http://www.w3.org/2002/07/owl#> .

<http://example.org/resource/celex/61960CC0002> rdf:type cdm:case-law ,
                                                         cdm:document_cjeu ,
                                                         cdm:opinion_advocate-general ,
                                                         cdm:resource_legal ,
                                                         cdm:work ,
                                                 cdm:resource_legal_number_natural_celex "0002"^^xsd:positiveInteger ;
 cdm:resource_legal_year "1960"^^xsd:gYear .

<http://example.org/resource/celex/61960CC0002.BUL> rdf:type cdm:expression .                                              
#+END_EXAMPLE

The mimetype of Turtle is ~application/x-turtle~, the typical file extension ~TTL~ (cf. also above for the treatment in the seabass library).

*** RDF/XML
Probably the most frequent pure RDF encoding is ~RDF/XML~ which is, as the name suggests, an XML-based serialization format for RDF: 

#+BEGIN_EXAMPLE
<rdf:RDF xmlns="http://www.w3.org/2002/07/owl#"
     xml:base="http://www.w3.org/2002/07/owl"
     xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
     xmlns:cdm="http://publications.europa.eu/ontology/cdm#"
     xmlns:cdm-annotation="http://publications.europa.eu/ontology/annotation#"
     xmlns:owl="http://www.w3.org/2002/07/owl#"
     xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
     xmlns:skos="http://www.w3.org/2004/02/skos/core#">
  <cdm:judgement rdf:about="http://example.org/resource/celex/62007CJ0535">
        <rdf:type rdf:resource="&cdm;document_cjeu"/>
        <rdf:type rdf:resource="&cdm;judgement"/>
        <cdm:resource_legal_number_natural_celex rdf:datatype="&xsd;positiveInteger">0535</cdm:resource_legal_number_natural_celex>
        <cdm:resource_legal_year rdf:datatype="&xsd;gYear">2007</cdm:resource_legal_year>    
  </cdm:judgement>

  <cdm:expression rdf:about="http://example.org/resource/celex/62007CJ0535.ITA">
        <cdm:expression_title rdf:datatype="&xsd;string">Sentenza della Corte (Seconda Sezione) del 14 ottobre 2010. # Commissione europea contro Repubblica d&apos;Austria. # Inadempimento di uno Stato - Direttive 79/409/CEE e 92/43/CEE - Conservazione degli uccelli selvatici - Designazione erronea e tutela giuridica insufficiente delle zone di protezione speciale. # Causa C-535/07.</cdm:expression_title>
        <cdm:expression_belongs_to_work rdf:resource="http://example.org/resource/celex/62007CJ0535"/>
        <cdm:expression_uses_language rdf:resource="http://publications.europa.eu/resource/authority/language/ITA"/>
    </cdm:expression>
</rdf:RDF>
#+END_EXAMPLE

In all of these cases the subject can also be indicated by the ~rdf:Description~ element with an explicit ~rdf:type~ that indicates the correct type. This example uses an abbreviation that uses (one of) the types as the class name.

The subject is always indicated by the ~rdf:about~ attribute, the predicate as the element name (e.g. ~cdm:expression_title~), the object by the ~rdf:resource~ attribute. In the case of data properties, ~rdf:datatype~ can be used ot indicate the correct datatype.

In order to mark up common concepts such as the Italian language in this example, the RDF examples refer to codes defined elsewhere in authority tables.

*** RDFa
RDFa is, in the words if the W3C recommendation http://www.w3.org/TR/rdfa-syntax/, "Syntax and processing rules for embedding RDF through attributes" into a markup language, virtually always (X)HTML. The same webpage is then both human-readable and machine-readable.

RDFa largely operates through attributes that either already exist in HTML or are newly added. In fact, RDFa means "RDF in Attributes".

For the ~property~ and ~rel~ attributes this looks as follows (all examples taken directly from the RDFa 1.1 specification http://www.w3.org/TR/rdfa-syntax/):

#+BEGIN_EXAMPLE
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>My home-page</title>
    <meta property="http://purl.org/dc/terms/creator" content="Mark Birbeck" />
    <link rel="http://xmlns.com/foaf/0.1/topic" href="http://www.example.com/#us" />
  </head>
  <body>...</body>
</html>
#+END_EXAMPLE

This means that the data property ~http://purl.org/dc/terms/creator~, in this case defined by the Dublin Core specification, has the value ~Mark Birbeck~. The link to ~http://www.example.com/#us~ is to be interpreted as a Friend of a Friend (FOAF) topic ~http://xmlns.com/foaf/0.1/topic~.

Just like for Turtle it is possible to define abbreviations through prefixes. The following is exactly equivalent to the previous example:

#+BEGIN_EXAMPLE
<html
  xmlns="http://www.w3.org/1999/xhtml"
  prefix="foaf: http://xmlns.com/foaf/0.1/
          dc: http://purl.org/dc/terms/"
  >
  <head>
    <title>My home-page</title>
    <meta property="dc:creator" content="Mark Birbeck" />
    <link rel="foaf:topic" href="http://www.example.com/#us" />
  </head>
  <body>...</body>
</html>
#+END_EXAMPLE

In principle, the ~prefix~ attribute can be used on any element (though in reality this is rarely used).

If the content is already present on the human readable page, it can just be reused and an explicit ~content~ attribute is not needed:

#+BEGIN_EXAMPLE
<html
  xmlns="http://www.w3.org/1999/xhtml"
  prefix="dc: http://purl.org/dc/terms/"
  >
  <head><title>My Home Page</title></head>
  <body>
    <h1 property="dc:title">My home-page</h1>
    <p>Last modified: 16 September 2015</p>
  </body>
</html>
#+END_EXAMPLE

If necessary, the information on the content can be explicitly typed using the ~datatype~ property:
#+BEGIN_EXAMPLE
<html
  xmlns="http://www.w3.org/1999/xhtml"
  prefix="xsd: http://www.w3.org/2001/XMLSchema#
          dc: http://purl.org/dc/terms/"
  >
  <head><title>My Home Page</title></head>
  <body>
    <h1 property="dc:title">My home-page</h1>
    <p>Last modified: <span property="dc:modified"
            content="2015-09-16T16:00:00-05:00"
            datatype="xsd:dateTime">16 September 2015</span>.</p>
  </body>
</html>
#+END_EXAMPLE




In all these cases the subject of the triples is implicitly the webpage itself. RDFa also permits to indicate explicit information on other subjects using the ~about~ property:

#+BEGIN_EXAMPLE
<html
  xmlns="http://www.w3.org/1999/xhtml"
  prefix="bibo: http://purl.org/ontology/bibo/
          dc: http://purl.org/dc/terms/"
  >
  <head>
    <title>Books by Marco Pierre White</title>
  </head>
  <body>
    I think White's book
    '<span about="urn:ISBN:0091808189" 
           property="dc:title">Canteen Cuisine</span>'
    is well worth getting since although it's quite advanced stuff, he
    makes it pretty easy to follow. You might also like
    <span 
     about="urn:ISBN:1596913614" 
     property="dc:description"
     >White's autobiography</span>.
  </body>
</html>
#+END_EXAMPLE

If really needed, ~rdf:type~ can be indicated through the ~typeof~ attribute.

Finally, it is possible to markup also the object of a triple explicitly, indicating in this example that Albert Einstein lived, in terms of the DBpedia ontology, both in the German empire and in Switzerland:

#+BEGIN_EXAMPLE
<div about="http://dbpedia.org/resource/Albert_Einstein" rel="dbp-owl:residence">
  <span about="http://dbpedia.org/resource/German_Empire"></span>
  <span about="http://dbpedia.org/resource/Switzerland"></span>
</div>
#+END_EXAMPLE

In full, the following attributes are defined in the RDFa recommendation, section 5:

- about: a SafeCURIEorCURIEorIRI, used for stating what the data is about (a 'subject' in RDF terminology);
- content: a CDATA string, for supplying machine-readable content for a literal (a 'literal object', in RDF terminology);
- datatype: a TERMorCURIEorAbsIRI representing a datatype, to express the datatype of a literal;
- href (optional): a traditionally navigable IRI for expressing the partner resource of a relationship (a 'resource object', in RDF terminology);
- inlist: An attribute used to indicate that the object associated with a rel or property attribute on the same element is to be added to the list for that predicate. The value of this attribute must be ignored. Presence of this attribute causes a list to be created if it does not already exist.
- prefix: a white space separated list of prefix-name IRI pairs of the form NCName ':' ' '+ xsd:anyURI
- property: a white space separated list of TERMorCURIEorAbsIRIs, used for expressing relationships between a subject and either a resource object if given or some literal text (also a 'predicate');
- rel: a white space separated list of TERMorCURIEorAbsIRIs, used for expressing relationships between two resources ('predicates' in RDF terminology);
- resource: a SafeCURIEorCURIEorIRI for expressing the partner resource of a relationship that is not intended to be navigable (e.g., a 'clickable' link) (also an 'object');
- rev: a white space separated list of TERMorCURIEorAbsIRIs, used for expressing reverse relationships between two resources (also 'predicates');
- src (optional): an IRI for expressing the partner resource of a relationship when the resource is embedded (also a 'resource object');
- typeof: a white space separated list of TERMorCURIEorAbsIRIs that indicate the RDF type(s) to associate with a subject;
- vocab: A IRI that defines the mapping to use when a TERM is referenced in an attribute value. 

CURIes in this context are "compact URI expressions", essentially abbreviated URIs. 

** Exercise: Markup of a web page
Markup a Wikipedia page, e.g. http://en.wikipedia.org/wiki/The_hobbit, with the DBpedia ontology

cf. also http://wiki.dbpedia.org/Ontology?v=194q for the ontology and http://dbpedia.org/page/The_Hobbit for the "solution" of dbpedia

[[img/the_hobbit_rdfa.png]]

** Facebook and RDFa: the Open Graph protocol
Facebook uses RDFa to integrate with external webpages. The Open Graph protocol http://opengraphprotocol.org/ / http://ogp.me/ defines a vocabulary that can be used to integrate metadata into a webpage. In fact, this vocabulary is itself defined in RDF and available under http://ogp.me/ns/ogp.me.ttl. It defines the following core properties ("basic metadata") that should always be present (cited after http://ogp.me/):

- ~og:title~ - The title of your object as it should appear within the graph, e.g., "The Rock".
- ~og:type~ - The type of your object, e.g., "video.movie". Depending on the type you specify, other properties may also be required.
- ~og:image~ - An image URL which should represent your object within the graph.
- ~og:url~ - The canonical URL of your object that will be used as its permanent ID in the graph, e.g., "http://www.imdb.com/title/tt0117500/".

~og~ stands for http://ogp.me/ns#.

This information should be given in metatags in the HTML header, though this is a Facebook restriction, not an RDFa one:

#+BEGIN_EXAMPLE
<html>
  <head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# book: http://ogp.me/ns/book#">
    <title>OG Sample Object - Geordnetes Weltbild</title>

    <meta property="og:title" content="Geordnetes Weltbild" />
    <meta property="og:image" content="http://www.budabe.de/img/geordnetes_weltbild_cover_1.jpg" />
    <meta property="og:url" content="http://www.budabe.eu/static/geordnetes_weltbild" />
    <meta property="og:type" content="book" />
  </head>
  <body>
  ...
  </body>
</html>
#+END_EXAMPLE

In addition to these mandatory elements the following optional metadata elements are possible for all types of objects:

- og:audio - A URL to an audio file to accompany this object.
- og:description - A one to two sentence description of your object.
- og:determiner - The word that appears before this object's title in a sentence. An enum of (a, an, the, "", auto). If auto is chosen, the consumer of your data should chose between "a" or "an". Default is "" (blank).
- og:locale - The locale these tags are marked up in. Of the format language_TERRITORY. Default is en_US.
- og:locale:alternate - An array of other locales this page is available in.
- og:site_name - If your object is part of a larger web site, the name which should be displayed for the overall site. e.g., "IMDb".
- og:video - A URL to a video file that complements this object


Individual types of objects can and often have more specific metadata in addition to the generic ones. A book for example can have the following metadata elements (namespace http://ogp.me/ns/book#):

- book:author - profile array - Who wrote this book.
- book:isbn - string - The ISBN
- book:release_date - datetime - The date the book was released.
- book:tag - string array - Tag words associated with this book.

The following types of objects are predefined (all of them have their own namespaces):
- website
- music with subtypes music.song, music.album, music.playlist and music.radio_station
- video with subtypes video.movie, video.episode, video.tv_show, video.other
- article
- book
- profile

In addition, Facebook itself defines a number of extensions in the http://ogp.me/ns/fb# namespace, notably:
-   fb:app_id: the application id in Facebook, e.g. 230196110444178
-   fb:admins: one or more ids of Facebook users that can get administrative information on this object, e.g. 100004654151051

Facebook can then directly use this metadata integrating information on a resource into Facebook itself, e.g. for the "liking" of resources. You can access this information by going through the like button with for the administrator(s) will now contain an additional link to this admin page.

[[img/facebook_activities.png]]

In the application configuration, e.g. for https://developers.facebook.com/apps/230196110444178, an application can even go beyond this. It can define action types (= object properties in OWL terms) e.g. to rate a book. For this it can either reuse existing object types or even define completely new ones. It can also define new object types (= classes in OWL terms).

[[img/app_center_open_graph.png]]

An application can indicate its intention to publish things on Facebook through the like button:

#+BEGIN_EXAMPLE
<fb:like href="http://www.goodreads.com/book/show/13010670-programming-clojure" width="280" layout="standard" show_faces="true" action="like" colorscheme="light" font="arial" />
#+END_EXAMPLE


In all of these cases Facebook extracts metadata in the website to populate the information in Facebook. This metadata is precisely the one encoded in RDFa. To test this integration the company has created a debugger for metadata: http://developers.facebook.com/tools/debug/og/object. You can use it for example: http://developers.facebook.com/tools/debug/og/object?q=http%3A%2F%2Fwww.goodreads.com%2Freview%2Fshow%2F488396402. Google has a corresponding tool, http://www.google.com/webmasters/tools/richsnippets that also supports the Open Graph Protocol.

However, Facebook goes a step further. In the application center a developer can define new RDF objects based on the Open Graph Protocol with new elements inside. What is more, the system then automatically creates a sample website with RDFa data integrated, e.g. http://samples.ogp.me//199815506812566 for a sample application on book rating. In other terms, Facebook permits to extend the existing ontology with new properties and classes:

[[img/open_graph_new_properties.png]]

[[img/open_graph_new_class.png]]


What is more, the tool automatically generates a sample object, e. g. for book: https://graph.facebook.com/10151191340470101/, and instructions on how to call the corresponding web services that an application can use to post its entries directly to a user's timeline:
#+BEGIN_EXAMPLE
curl -F 'access_token=XXXXX'      -F 'book=http://samples.ogp.me/199815506812566'         'https://graph.facebook.com/me/worms-web:rate'

curl -F 'access_token=XXXX'      -F 'book=https://www.budabe.eu/static/geordnetes_weltbild'         'https://graph.facebook.com/me/worms-web:rate'
#+END_EXAMPLE

With aggregations it is possible to calculate numbers of smaller activities, e.g. this user has heard 200 songs last months.

At this stage many of the big players from http://imdb.com, http://www.amazon.com, http://digg.com, https://www.spotify.com, http://www.goodreads.com/ all integrate in this way with Facebook, using the Facebook authentication, sometimes amongst others such as the Twitter or Google authentication.

http://youtu.be/TM-2fNtg7p8 and http://youtu.be/__FplazeKvU give a good idea on the business reasons that Facebook has to integrate Facebook with all sorts of objects outside it, making effectively a part of Facebook. This specific take on a semantic web of things that monitors a users activities --- books, music, runs, whatever --- is at the same time techically fascinating and obviously disquieting from a privacy point of view.



* Excursion: Web Services in .NET
Special guest: Lukas Georgieff, talking about SOAP-based and RESTful web services on the .NET platform using C#

Session <2012-11-30 Fri>
- .Net-Framework
- Windows Communication Foundation
  - Architecture
  - Contracts and Description
  - Service Runtime
  - Messaging
  - Hosting and Activation
- SOAP and WCF
  - Music Store (Service)
    - Requirements
    - Implementation
      - Create a Visual Studio WCF-Project
      - Service and Operation Contracts
      - Message and Data Contracts
      - loginUser and postUserImage
      - Binding
    - Live Coding: Echo Service
  - Music Store (Client): Implementation
    - Service-Reference
    - Calling Stub-Methods

Session <2012-12-01 Sat>
- RESTful and WCF
   - Music Store (Service)
     - Implementation
       - Service and Operation Contracts
       - UriTemplate, WebGet and WebInvoke
       - Data Contracts
       - loginUser, postUserImage and WebOperationContext
       - Binding
    - Live Coding: Echo Service
    - Music Store (Client): Implementation
      - WebChannelFactory
      - Implementing a RESTful Stub

* Bibliography
* Excursion: Clojure and JVM
** Why Clojure?
Clojure is a Lisp for the JVM, the Java platform. It combines the advantages of Lisp, notably its flexible and clean syntax, with full interoperability with existing Java libraries and excellent support for concurrent programming. 

At here two ultimatively simple examples:
#+BEGIN_EXAMPLE
user=> (+ 1 1)
2
user=> (println "Hello World!")
Hello World!
nil
user=> 
#+END_EXAMPLE

Like other Lisps Clojure employs prefix notation for function calls. Things like ~+~ that in other languages are separate operators are ordinary functions, following the same logic as any other function. In the case of ~+~ we have what is called a /pure/ function that does not produce side-effects. The ~println~ in turn does not return anything useful --- though it does return something, the value ~nil~ ---, but it triggers a side action, namely to print out a string on the console.

Before we elaborate more on the advantages let's have a look at some slightly more complex Clojure code (example inspired by , p.3):

#+BEGIN_EXAMPLE
user=> (defn all-lower? [s] (every? #(Character/isLowerCase %) s))
#'user/all-lower?
user=> (all-lower? "aBc")
false
user=> (all-lower? "abc")
true
#+END_EXAMPLE

This short code defines boolean function --- a predicate --- with one parameter using ~defn~. This function checks if all characters in a string are lower-case. It works by just checking if another predicate, -Character/isLowerCase- is true for every character in the string. If so, it returns ~true~, otherwise ~false~.

Already this example is a typical use of functions that themselves call functions (higher-order functions). We can, however, use this function in turn in a larger context, e.g. to filter all all-lower-case strings from a list of strings
#+BEGIN_EXAMPLE
user=> (filter all-lower? '("aBc" "deF" "hij" "Klm" "nop" "QRS" "tuV" "WXy" "z"))
("hij" "nop" "z")
user=> 
#+END_EXAMPLE

That code demonstrates two things:
- Combination of functions allows for a highly declarative style of programming. The above code ready almost like an instruction in ordinary language: filter all strings from this list of string that are in all lower case
- Like all Lisps Clojure follows a philosophy of "code is data", i.e. there are no structural differences between Lisp code and data structures (everything look structurally the same). This principle is known as homoiconicity.

Function definitions can be more complex in that you can have multiple set of parameters, in the following case none (case -[]-), one (case -[name]-) and two (case -[phrase name]):
#+BEGIN_SRC clojure
(defn hello
  ([]
     (hello "Hello" "World"))
  ([name]
     (hello "Hello" name))
  ([phrase name]
     (str phrase ", " name)))
#+END_SRC

Based on the parameters given the right function is chosen:

#+BEGIN_EXAMPLE
user=> (hello)
"Hello, World"
user=> (hello "Worms")
"Hello, Worms"
user=> (hello "Hallo" "Worms")
"Hallo, Worms"
user=> 
#+END_EXAMPLE




On this basis we can now look at some more of the advantages:

- Elegant and concise syntax
- Largely immutable data structures
- Excellent support for concurrent programming
- Close JVM integration

Recommended reading: {Halloway:2012ta}

** Practicalities
*** Tutorials
A number of Clojure tutorials exist on the Web, both as written tutorials and as podcasts. In addition, a number of books have appeared:

**** Books
[1]	S. Halloway and A. Bedra, Programming Clojure, Second Edition. Pragmatic Bookshelf, 2012.
[1]	C. Emerick, B. Carper, and C. Grand, “Clojure Programming - Practical LISP for the Java World.,” O'Reilly 2012, 

**** Podcasts

http://blip.tv/clojure/clojure-for-java-programmers-1-of-2-989128

http://blip.tv/clojure/clojure-for-java-programmers-2-of-2-989262

**** API
The Clojure API is documented under http://clojure.github.com/clojure/

*** Installation and integration with Emacs
1. Download leiningen 2.0

Download from http://leiningen.org/

#+BEGIN_EXAMPLE
  wget https://raw.github.com/technomancy/leiningen/preview/bin/lein

  chmod 755 lein

  ./lein self-install
#+END_EXAMPLE

then move lein to a place in the PATH

2. Install package manager

Only for Emacs 23: 

Install the Marmalade package manager

#+BEGIN_EXAMPLE
(require 'package)
(add-to-list 'package-archives
             '("marmalade" . "http://marmalade-repo.org/packages/"))
(package-initialize)
#+END_EXAMPLE

3. Install clojure-mode

https://github.com/technomancy/clojure-mode

4. Install nrepl

https://github.com/kingtim/nrepl.el

M-x package-install [RET] nrepl [RET]

Configure in .emacs:
#+BEGIN_SRC
(require 'package)
(add-to-list 'package-archives
             '("marmalade" . "http://marmalade-repo.org/packages/") t)
(add-to-list 'package-archives
             '("melpa" . "http://melpa.milkbox.net/packages/") t)
(package-initialize)

(require 'clojure-mode) ;;https://github.com/technomancy/clojure-mode/blob/master/clojure-mode.el

(setq inferior-lisp-program "lein repl")
(setq clojure-swank-command ;; https://github.com/pallet/ritz/tree/develop/swank
  (if (or (locate-file "lein" exec-path) (locate-file "lein.bat" exec-path))
    "lein ritz-in %s"
    "echo \"lein ritz-in %s\" | $SHELL -l"))
#+END_SRC

5. Start nrepl

M-x nrepl-jack-in

For Eclipse users there is the Counterclockwise plugin that can be used instead (http://code.google.com/p/counterclockwise/). For installation instructions see there.

*** Leiningen
Leiningen (http://leiningen.org) is the standard tool for managing dependencies for Clojure. It builds on the standard Java tool for this purpose, Maven, but adds a much more simpler syntax to express dependencies.

Like Maven projects Leiningen projects have a predefined directory structure:

#+BEGIN_EXAMPLE
project/src            Source code
       /test           Unit tests
       /project.clj    Dependency file
#+END_EXAMPLE

Project files with the dependency structure just list the packages and their desired versions:

#+BEGIN_SRC clojure
(defproject eu.budabe/eli-project "0.1" 
  :dependencies [[org.clojure/clojure "1.4.0"]
                 [clj-http "0.5.3"]
                 [cheshire "4.0.2"]
                 [org.clojure/data.zip "0.1.0"]])
#+END_SRC

Leiningen itself will then automatically download the necessary libraries and install them as necessary. Much like Python, Perl and Ruby Clojure has a universally accepted central repository http://clojars.org which hosts Clojure libraries. In addition, all "normal" Java libraries can also be used.

Leiningen itself has a number of options, most of which are self-explanatory.

#+BEGIN_EXAMPLE
marcwilhelmkuster$ lein --help
Leiningen is a tool for working with Clojure projects.

Several tasks are available:
check               Check syntax and warn on reflection.
classpath           Write the classpath of the current project to output-file.
clean               Remove all files from project's target-path.
compile             Compile Clojure source into .class files.
deploy              Build jar and deploy to remote repository.
deps                Show details about dependencies.
do                  Higher-order task to perform other tasks in succession.
help                Display a list of tasks or help for a given task.
install             Install current project to the local repository.
jar                 Package up all the project's files into a jar file.
javac               Compile Java source files.
new                 Generate project scaffolding based on a template.
plugin              DEPRECATED. Please use the :user profile instead.
pom                 Write a pom.xml file to disk for Maven interoperability.
repl                Start a repl session either with the current project or standalone.
retest              Run only the test namespaces which failed last time around.
ritz                Launch ritz server for Emacs to connect.
ritz-in             Jack in to a ritz backed Clojure SLIME session from Emacs.
run                 Run the project's -main function.
search              Search remote maven repositories for matching jars.
show-profiles       List all available profiles or display one if given an argument.
test                Run the project's tests.
trampoline          Run a task without nesting the project's JVM inside Leiningen's.
uberjar             Package up the project files and all dependencies into a jar file.
upgrade             Upgrade Leiningen to specified version or latest stable.
version             Print version for Leiningen and the current JVM.
with-profile        Apply the given task with the profile(s) specified.

Run lein help $TASK for details.

Aliases:

See also: readme, faq, tutorial, news, sample, profiles,
deploying and copying.
#+END_EXAMPLE

~lein repl~ starts a Clojure command shell with all dependencies loaded:
#+BEGIN_EXAMPLE
marcwilhelmkuster$ lein repl
nREPL server started on port 55766
REPL-y 0.1.0-beta10
Clojure 1.4.0
    Exit: Control+D or (exit) or (quit)
Commands: (user/help)
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
          (user/sourcery function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
Examples from clojuredocs.org: [clojuredocs or cdoc]
          (user/clojuredocs name-here)
          (user/clojuredocs "ns-here" "name-here")
user=> (+ 1 1)
2
user=> (defn all-lower? [s] (every? #(Character/isLowerCase %) s))
#'user/all-lower?
user=> (all-lower? "aBc")
false
user=> (all-lower? "abc")
true
user=> 
#+END_EXAMPLE

~lein new PROJECT~ creates a new empty project structure with placeholders for all important files:

#+BEGIN_EXAMPLE
$ lein new b5
Generating a project called b5 based on the 'default' template.
To see other templates (app, lein plugin, etc), try `lein help new`.
$ cd b5
$ find . -name "*"
.
./.gitignore
./doc
./doc/intro.md
./project.clj
./README.md
./src
./src/b5
./src/b5/core.clj
./test
./test/b5
./test/b5/core_test.clj
$ 
#+END_EXAMPLE

The Leiningen tutorial https://github.com/technomancy/leiningen/blob/master/doc/TUTORIAL.md illustrates all possible operations in detail.

*** Syntax and data structures
We have already seen examples of Clojure's syntax. Function calls are of the type:
#+BEGIN_EXAMPLE
user=> (function-name params listed)
#+END_EXAMPLE


Defining new functions is as simple:
#+BEGIN_SRC clojure
(defn all-lower? [s] (every? #(Character/isLowerCase %) s))
#+END_SRC

In total the following primitive data structures exist in Clojure:
#+BEGIN_EXAMPLE
Boolean: true | false
Character: \a \b \c
String: "abc"
List: ("a" "b" "c") (all-lower? "abc")
Map: {:key1 "Value1", :key2 "Value2"}
Number: 1.23
Set: #{ 1 2 3}
Vector: [1 2 3]

Symbol: eli/build-act
Keywords: :keyword :name
Nil: nil
#+END_EXAMPLE

**** Lists
Lisps are famous for using lists. In Clojure lists are also key to the syntax, but not anywhere as strongly as in classical Lisps.

#+BEGIN_EXAMPLE
user=> (list 1 2 3)
(1 2 3)
user=> (list 1 2 "a" "b")
(1 2 "a" "b")
user=> '(1 2 "a" "b")
(1 2 "a" "b")
user=> (quote (1 2 "a" "b"))
(1 2 "a" "b")
user=> (list 1 2 (+ 3 4))
(1 2 7)
user=> '(1 2 (+ 3 4))
(1 2 (+ 3 4))
user=> 
#+END_EXAMPLE

As we have seen, also function calls are lists:
#+BEGIN_EXAMPLE
user=> (all-lower? "abc")
true
#+END_EXAMPLE


**** Vectors
Vectors are Clojure's equivalent to arrays. They are indexed, indexes can be used to address individual elements in the vector.
#+BEGIN_EXAMPLE
user=> [1 2 3]
[1 2 3]
user=> (def v [1 2 3])
#'user/v
user=> (vector? v)
true
user=> (v 1)
2
user=> 
user=> [1 2 "a" "b"]
[1 2 "a" "b"]
user=> 
#+END_EXAMPLE

Vectors themselves can be used as functions, taking the relevant index as a parameter.

**** Maps
Maps are very much the bread and butter data structure in Clojure and are used to model flexible data structures:

#+BEGIN_EXAMPLE
user=> {:first-name "Marc", :last-name "Kuester"}
{:last-name "Kuester", :first-name "Marc"}
user=> (def kuester {:first-name "Marc", :last-name "Kuester"})
#'user/kuester
user=> (:last-name kuester)
"Kuester"
user=> 
#+END_EXAMPLE

Using the comma to separate key-value-pairs is optional. All data structures can be used as as keys, though keywords are the most common case. Keywords can also be used as functions, they return the value corresponding to this key in the map.

**** -defrecord-
In addition, you can easily define new data structures in the form of records:
#+BEGIN_EXAMPLE
user=> (defrecord Teacher [first-name last-name office-no])
user.Teacher
user=> (->Teacher "Marc" "Kuester" 123)
#user.Teacher{:first-name "Marc", :last-name "Kuester", :office-no 123}
user=> (:first-name (->Teacher "Marc" "Kuester" 123))
"Marc"
user=> 
#+END_EXAMPLE


** Control structures
Clojure has at its core only very simple comtrol structures: ~if~, ~do~ and ~loop~. Of these, however, you use only ~if~ regularly and directly:

#+BEGIN_EXAMPLE
user=> (defn all-lower? [s] (every? #(Character/isLowerCase %) s))
user=> (if (all-lower? "abc") "all lower case" "also capital letters")
"all lower case"
user=> 
#+END_EXAMPLE

The first branch is used if the condition is true ("then-branch"), the second one if it is false ("else-branch"). Incidentally, if is a function like all other functions, returning the then or else branch as the case may be.

#+BEGIN_EXAMPLE
user=> (def a (if (all-lower? "abc") "all lower case" "also capital letters"))
#'user/a
user=> a
"all lower case"
user=> (def b (if (all-lower? "aBc") "all lower case" "also capital letters"))
#'user/b
user=> b
"also capital letters"
user=> 
#+END_EXAMPLE

~do~ is needed if for some reason more than one action is needed in the then or else branch. By necessity, these other actions are defined by their side effect:
#+BEGIN_EXAMPLE
user=>  (if (all-lower? "aBc") (do (println "then") "all lower case") (do (println "else") "also capital letters"))
else
"also capital letters"
user=> 
#+END_EXAMPLE


~loop~ is hardly ever used directly. Here an example of a loop that calculates the squares of all even numbers:
#+BEGIN_SRC clojure
;;very complicated, do not use
(loop [lst '(1 2 3 4 5 6) res '()]  
(let [l (last lst)]
(if (empty? lst)
  res
  (recur (drop-last lst) (if (even? l) (cons (* l l) res) res)))))
#+END_SRC

As usual for Lisps these primitive control structures are replaced by more powerful abstractions built on top of these basic building blocks. These include ~for~ and ~when~. ~for~, however, has little in common with a for-loop in, say, C. Ui stead it is a close parent of the list comprehensions that exist e.g. in Python:

#+BEGIN_EXAMPLE
user=> (for [i '(1 2 3 4 5 6) :when (even? i)] (* i i))
(4 16 36)
user=> 
#+END_EXAMPLE

Really, the use of explicit control structures is much rarer in Clojure than in traditional imperative languages. Instead, higher-order functions operating on sequences are the bread and butter of Clojure ans indeed of functional programming in general.

So, instead of using the above idiom to output the squares of even numbers a even more idiomatic approach would be:

#+BEGIN_EXAMPLE
user=> (map (fn [i] (* i i)) (filter even? '(1 2 3 4 5 6)))
(4 16 36)
user=> 
#+END_EXAMPLE

or even shorter

#+BEGIN_EXAMPLE
user=> (map  #(* % %) (filter even? '(1 2 3 4 5 6)))
(4 16 36)
user=> 
#+END_EXAMPLE

This makes usually for much clearer code.

** Lazy sequences
However, Clojure still has a surprise  in petto. In contrast to most other languages it does not only know finite, but also infinite sequences. With this we can find a much more flexible definition for our squares of even numbers, one that does not only work for a given finite list '(1 2 3 4 5 6), but for any type of range:
#+BEGIN_EXAMPLE
user=> (defn even-squares [] (map #(* % %) (filter even? (range))))
#'user/even-squares
user=> (take 10 (even-squares))
(0 4 16 36 64 100 144 196 256 324)
user=> (take 50 (even-squares))
(0 4 16 36 64 100 144 196 256 324 400 484 576 676 784 900 1024 1156 1296 1444 1600 1764 1936 2116 2304 2500 2704 2916 3136 3364 3600 3844 4096 4356 4624 4900 5184 5476 5776 6084 6400 6724 7056 7396 7744 8100 8464 8836 9216 9604)
user=> 
#+END_EXAMPLE

or even shorter

#+BEGIN_EXAMPLE
user=> (defn even-squares [] (map #(* % %)  (range 0 Double/POSITIVE_INFINITY 2)))
#'user/even-squares
user=> (take 10 (even-squares))
(0 4 16 36 64 100 144 196 256 324)
user=> 
#+END_EXAMPLE


This may look rather surprising --- how can a language treat infinite sequences? This only works because Clojure treats these sequences as so-called lazy sequences that are instantiated --- realized is the term --- only when really used. So, before we actually take the first 10 squares, nothing is calculated. Only the moment that we really want to print those 10 and then in a second round 50 squares are they really calculated. Results that are no longer needed can be garbage collected.

Lazy sequences make for elegant code also for finite, but potentially large sequences. Results of database queries can be of considerable size and often necessitate paging to treat batches of results one after the other. Lazy sequences can abstract from this detail without loading all results into memory. 

** Assignment
1. Write a clojure program that takes a list of strings and returns another list of only those strings that start with the character "a", but uppercased. So, e.g. for an input '("xyz" "cde" "abc" "bab" "axx") it should return '("ABC" "AXX"). Write first a unit test and then the function and run lein test to prove it works.
2. Write the same program in another programming language of your choice

Hand in assignment via the course's Moodle page.


** Principles of functional programming
Session <2012-10-19 Fri>

Functional programming centres around a number of key principles that are more or less "purely" realized in the various functional languages:

  - Immutable data
  - Functions as data
  - Pure Functions
  - Higher-Order Functions
  - Use of recursion

We have seen cases of function as data and higher order functions. These are key to all functional languages and especially to Clojure. Clojure also has a strong preference for pure functions, i.e. functions that have no side-effects and always return the same output for the same input. 

The example of the "square of even numbers" functions is built on functions as data (~even?~, ~#(* % %)~ etc.) that are parameters to higher-order functions (~filter~, ~map~). All of these functions are pure in a mathematical sense.
#+BEGIN_SRC clojure
(map  #(* % %) (filter even? '(1 2 3 4 5 6)))
#+END_SRC 

Clojure is less oriented towards explicit recursion as other languages such as Scheme, but they still play an important role. However, the concept of immutable data is at the core of Clojure. All the data structures that we have seen are immutable (and many are in addition lazy). Of course, it is still possible to handle mutable data, and in fact Clojure offers some powerful strategies to handle data updates in transactions (Software Transactional Memory or STM). Transactional references (Refs) make for safe mutable data. However, a detailed discussion of this is out of scope for this session.

More information on Clojure and its API is available under http://clojure.org/ and http://clojuredocs.org/






** Futures
For long-running calculations Clojure has the concept of futures (http://clojuredocs.org/clojure_core/clojure.core/future). A future is calculated in a separate thread, but transparently to the user:

#+BEGIN_SRC clojure
(defn get-page [host port]
  (let
      [conn (Socket. host port)
       in (.getInputStream conn)
       out (.getOutputStream conn)]
    (write-request out host)
    (future (read-response in))))
#+END_SRC 

Assuming that ~read-response~ takes a considerable time to execute and would block further program execution for the time it takes, ~(future (read-response in))~ returns instead a /promise/ to the real value that it will contain. Once the calculation is complete, it will be transparently replaced by the final value, without blocking the current execution:

#+BEGIN_EXAMPLE
user> (def p (get-page "www.google.de" 80))
GET / HTTP/1.1
Host: www.google.de

Request written
#'user/p
user> p
#<core$future_call$reify__6110@2ca275d8: :pending>
user> 
user> p
#<core$future_call$reify__6110@2ca275d8: :pending>
user> @p
[now execution blocks until the page is fully retrieved]
#+END_EXAMPLE

If you need the guarantee to have the value at a later stage, you can dereference the future by using the ~@~ reader macro, e.g. ~@p~. In this case program execution will block until the correct value is calculated, if that is not yet the case.

** Multimethods: Polymorphism functional style

Clojure has no native concept of objects (it does have an object concept for interfacing with Java). Instead, it offers named data structures --- records --- as well as functions that can dispatch on them and indeed on many other criteria. In the simplest of cases we have 

#+BEGIN_SRC Clojure

(defrecord Variable [text postfix])

(defrecord Token [variables prefix])

(defmulti handle-value 
  "Handling of individual variables. Returns the variable replaced by the supplied values"
  (fn [^Variable variable values separator encoding-fn]
    (class (values (:text variable)))))

(defmethod handle-value String [^Variable variable values separator encoding-fn]
 ;one strategy for strings
)

(defmethod handle-value java.util.Collection [^Variable variable values separator encoding-fn]
 ; another strategy to handle collections
)
; and so on
#+END_SRC

In the most frequent case dispatching is by data type or class, but it can be by anything else. ~defmulti~ defines in its implementation the strategy to be chosen by the individual ~defmethod~.
