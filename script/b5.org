# -*- coding: utf-8; -*-
#+OPTIONS: ^:{}
#+TITLE: B5: Web Services 
#+AUTHOR: Marc Wilhelm Küster

#+BEGIN_HTML
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">B5 "Web Services"</span> by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Marc Wilhelm Küster</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/mwkuster/b5" rel="dct:source">https://github.com/mwkuster/b5</a>.
#+END_HTML
* Objectives and Formalia
Session <2012-10-05 Fri>
** Course objectives
Mastering the concepts and implementation of heterogeneous, loosely-coupled architectures using a substantial practical programming project


** Programming project
Course success is measured through a practical programming project,
followed by a short oral exam. This project can be started after the
basic web service part is over. I will suggest topics, but
participants can also propose their own projects as long as the
technologies fit in the overall scope of the course.

You can and should work in teams of two.

Precondition for participating in the practical programming project is regular participation in the practical courses. You must pass at least 80% of the weekly assignments. An assignment is considered a pass if you have at least 50 of points out of 100.

Repeating the exam means a second, new practical project followed by a second oral exam.

** Preconditions
- Preconditions for this module:  B4, D4
- Registration for course and exam within deadlines
- Participating in the final exam depends on having successfully completed a practical programming project
- Exam: consists of a practical programming project followed by a presentation and an oral exam
  
* RESTful Web Services and Resource Oriented Architectures
** The HTTP protocol
The Hypertext Transfer Protocol (HTTP) or RFC 2616 is next to the Uniform Resource Identifier (URI) the most important standard for the Web as we know it. Whenever we access anything on the web through a browser, we trigger at least one HTTP request, typically many. And not only through a browser: any mobile device uses HTTP requests, as do many software tools that are not browsers at all. 
               
In this session we will learn more about this specification and how it is used. Fortunately, the specification {Fielding:1999ub} itself is very clear and readable. It sets out with the HTTP's overall objective:
               
#+BEGIN_QUOTE  
The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems. It is a generic, stateless, protocol which can be used for many tasks beyond its use for hypertext, such as name servers and distributed object management systems, through extension of its request methods, error codes and headers. A feature of HTTP is the typing and negotiation of data representation, allowing systems to be built independently of the data being transferred (http://www.w3.org/Protocols/rfc2616/rfc2616.html)
#+END_QUOTE    
               
The key phrase --- and probably the main technical reason for HTTP's success --- is /stateless/. Generally, HTTP operates on pairs of request and response. Once a request has received its response, the protocol keeps no memory of the interaction, making each interaction independent. Of course, an HTTP request can very well change the state of the recipient, for example by adding a resource --- we'll shortly see how ---, but this remains transparent for the next request / response pair. The next interaction has no inherent knowledge if the state of the server has just been changed a millisecond earlier, was changed a month ago or has always been in this state: "interaction is stateless between requests" ({Fielding:2000vh}, 5.3.1). The server also has no need to keep a state related to the concrete set of interactions, nor even which sequence of interactions come from the same sender. "Session state is therefore kept entirely on the client" ({Fielding:2000vh}, 5.1.3).
               
If this sounds abstract, at the core it means that a sender --- let's say, the browser --- asks a server for a webpage, giving a URI to identify that page:
               
#+BEGIN_EXAMPLE
 -----------   Get Webpage       ----------
 |         | ------------------> |        |
 | Browser |                     | Server |
 |         | <------------------ |        |
 -----------  Send webpage       ----------
#+END_EXAMPLE

In reply, the server sends back the content of that website to the browser, and that's it.

Of course, there's a bit more to it, though the principle does not change.

*** HTTP methods and their use
**** GET-method
In the easiest scenario, the client just wants to get some content from the server. In this case sends a request that is in fact just called ~GET~:
#+BEGIN_EXAMPLE
$curl -v http://www.budabe.eu/research/
--> 
GET /research/ HTTP/1.1
User-Agent: curl/7.27.0
Host: www.budabe.eu
Accept: */*
#+END_EXAMPLE

This says pretty much what it seems to say: request the server to ~GET~ the URL webpage ~/research~ on the host ~www.budabe.eu~ and return its contents. If the page exists, the server responds by sending it back:

#+BEGIN_EXAMPLE
< HTTP/1.1 200 OK
< Date: Sat, 22 Sep 2012 15:09:33 GMT
< Server: Apache/2.2.20 (Ubuntu)
< Vary: Accept-Language,Cookie,Accept-Encoding
< Content-Language: de-de
< Transfer-Encoding: chunked
< Content-Type: text/html; charset=utf-8
< 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><!-- mode: nxml; code: utf-8; -->
<html version="-//W3C//DTD XHTML 1.1//EN" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>
Research
</title>
[...]
#+END_EXAMPLE

Again, this says pretty much what it seems to say: On a given date the server sends back an html-page (-Content-Type: text/htm-) encoded in Unicode and more precisely UTF-8. The most cryptic and at the same time the most important part of this is the ~200~ part, though, that says that the request has succeeded. The ~200~ return code is specified RFC 2616 alongside 37 others. We'll come back to these codes below.

Formally, ~GET~ is defined as:

#+BEGIN_QUOTE 
The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI. If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not the source text of the process, unless that text happens to be the output of the process ({Fielding:1999ub}, 9.3)
#+END_QUOTE

~GET~ returns existing webpages or more abstractly resources, if they exist, but it does not modify it. You can execute it any number of times, it will always return the resource. For this reason, it is called an idempotent method.

**** HEAD-method
"The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response" ({Fielding:1999ub}, 9.4):
#+BEGIN_EXAMPLE$ curl -v -XHEAD  http://www.budabe.eu/research/
$ curl -v -XHEAD  http://www.budabe.eu/research/ 
-->
> HEAD /research/ HTTP/1.1
> User-Agent: curl/7.27.0
> Host: www.budabe.eu
> Accept: */*
> 
< HTTP/1.1 200 OK
< Date: Sat, 22 Sep 2012 15:31:18 GMT
< Server: Apache/2.2.20 (Ubuntu)
< Vary: Accept-Language,Cookie,Accept-Encoding
< Content-Language: de-de
< Content-Type: text/html; charset=utf-8
 no chunk, no close, no size. Assume close to signal end
< 
#+END_EXAMPLE

Since the server does not return data, it is a quick way to test if a resource exists, is accessible and / or has recently been modified. Like ~GET~ ~HEAD~ is also idempotent.

**** DELETE-method
Another idempotent method is ~DELETE~ that does exactly what you'd assume it does: "The DELETE method requests that the origin server delete the resource identified by the Request-URI" ({Fielding:1999ub}, 9.7):

#+BEGIN_EXAMPLE
$ curl -v -XDELETE  http://www.budabe.eu/research/
-->
> DELETE /research/ HTTP/1.1
> User-Agent: curl/7.27.0
> Host: www.budabe.eu
> Accept: */*
> 
#+END_EXAMPLE

Of course, this does not mean that the sender has necessarily the right to do this and that the server will actually delete a resource. In this case, the server return a ~403~ (= forbidden) to indicate that it has no intention to delete it:
#+BEGIN_EXAMPLE
< HTTP/1.1 403 FORBIDDEN
< Date: Sat, 22 Sep 2012 15:28:08 GMT
< Server: Apache/2.2.20 (Ubuntu)
< Vary: Accept-Language,Cookie,Accept-Encoding
< Content-Language: de-de
< Transfer-Encoding: chunked
< Content-Type: text/html
< 
#+END_EXAMPLE

~DELETE~ is also idempotent in that we can issue it any number of times, the result will always be the same (i.e. given necessary rights the resource will have disappeared).

**** PUT-method
Another idempotent method is the ~PUT~ method. It "requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI. If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response" ({Fielding:1999ub}, 9.6). In other words, the client asks the server to generate a new resource or update an existing one for a given URI. The server has no leaway, it must create or update the resource under that URI or refuse the action.

In the following example the server is requested to create a page ~/research/WebService~ that currently does not exist:

#+BEGIN_EXAMPLE
$ curl -v -XPUT -d "01234567890123456789012345"  http://www.budabe.eu/research/WebService
-->
> PUT /research/WebService HTTP/1.1
> User-Agent: curl/7.27.0
> Host: www.budabe.eu
> Accept: */*
> Content-Length: 26
> Content-Type: application/x-www-form-urlencoded
> 
 upload completely sent off: 26 out of 26 bytes
#+END_EXAMPLE

As a payload, the string "Data for this new resource", which has a length of 26 bytes, is sent along.

Of course, as always the fact that you can send a ~PUT~ request to the server does not mean you have the necessary rights.

#+BEGIN_EXAMPLE
< HTTP/1.1 403 FORBIDDEN
< Date: Sun, 23 Sep 2012 10:08:50 GMT
< Server: Apache/2.2.20 (Ubuntu)
< Vary: Accept-Language,Cookie,Accept-Encoding
< Content-Language: de-de
< Transfer-Encoding: chunked
< Content-Type: text/html
#+END_EXAMPLE

Similarly, the following request asks for an update to an existing resource with the same 26 characters: 

#+BEGIN_EXAMPLE
$ curl -v -XPUT -d "01234567890123456789012345"  http://www.budabe.eu/research/WebService
-->
> PUT /research/ HTTP/1.1
> User-Agent: curl/7.27.0
> Host: www.budabe.eu
> Accept: */*
> Content-Length: 26
> Content-Type: application/x-www-form-urlencoded
> 
 upload completely sent off: 26 out of 26 bytes
#+END_EXAMPLE

If this had succeeded, the (existing) page http://www.budabe.eu/research/ would now have the new content.

Since the precondition for ~PUT~ is that the client knows the URI to which the data sent will be applied, this method is virtually always used ot update existing resources, not to create new ones.

If you had the rights, the answer would obligatorily have been ~201~ in both cases.

**** POST-method
If ~PUT~ normally updates existing resources, ~POST~ ist used to create new resources under a given URI. The client does not know in advance what the new URI will be, but will be informed by the server about this when things go according to plan. The server has a certain flexibility in interpreting the right action:

#+BEGIN_QUOTE  
The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI. The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it, a news article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database.
#+END_QUOTE  

Possible positive responses are:

- 200 (OK) or 204 (No Content) if no resource was created, but the action want OK
- 201 (Created) with a reference to the new resource if a new resource was created


*** Error handling
One of the strenghts of the HTTP protocol is that it has a clear semantics for handling possible errors through well-defined response codes. Leaving aside the hardly-ever used 1xx series of responses we have:

- Successful 2xx 
  - 200 OK 
  - 201 Created 
  - 202 Accepted 
  - 203 Non-Authoritative Information 
  - 204 No Content 
  - 205 Reset Content 
  - 206 Partial Content 
- Redirection 3xx 
  - 300 Multiple Choices 
  - 301 Moved Permanently 
  - 302 Found 
  - 303 See Other 
  - 304 Not Modified 
  - 305 Use Proxy 
  - 306 (Unused) 
  - 307 Temporary Redirect 
- Client Error 4xx 
  - 400 Bad Request 
  - 401 Unauthorized 
  - 402 Payment Required 
  - 403 Forbidden 
  - 404 Not Found 
  - 405 Method Not Allowed 
  - 406 Not Acceptable 
  - 407 Proxy Authentication Required 
  - 408 Request Timeout 
  - 409 Conflict 
  - 410 Gone 
  - 411 Length Required 
  - 412 Precondition Failed 
  - 413 Request Entity Too Large 
  - 414 Request-URI Too Long 
  - 415 Unsupported Media Type 
  - 416 Requested Range Not Satisfiable 
  - 417 Expectation Failed 
- Server Error 5xx 
  - 500 Internal Server Error 
  - 501 Not Implemented 
  - 502 Bad Gateway 
  - 503 Service Unavailable 
  - 504 Gateway Timeout 
  - 505 HTTP Version Not Supported 

*** Content negotiation 
So far we have seen only requests with the HTTP header ~Accept: */*~, which essentially says that you have no preference for the type of content to get back. However, normally clients have preferences for some type of content in some language over other types of content. In a typical browser session we see sequences like this:

#+BEGIN_EXAMPLE
Request:
http://www.budabe.eu/research/

GET /research/ HTTP/1.1
Host: www.budabe.eu
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:12.0) Gecko/20100101 Firefox/12.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: de-de,de;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate

Response:
HTTP/1.1 200 OK
Date: Sun, 23 Sep 2012 17:19:33 GMT
Server: Apache/2.2.20 (Ubuntu)
Vary: Accept-Language,Cookie,Accept-Encoding
Content-Language: de
Content-Encoding: gzip
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html; charset=utf-8
#+END_EXAMPLE
(protocol of a live session taken with the Live HTTP headers plugin in Firefox)

In contrast to the HTTP method the HTTP headers always follow the model: Header name ':' value of the header followed by a newline (theoretically a line continuation is possible, but rarely seen) (cf. {Fielding:1999ub}, 2.2 for the details of the BNF rules). In particular, ~Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8~
 requests in the order of preference ~text/html~ and XHTML (~application/xhtml+xml~), then other formats. The server is expected to honour these requests. Similarly, ~Accept-Language~ specifies a preference for German (~de~) over English (~en~). More languages are possible.

The very same logic can also be used for more web-service type requests to deliberatedly ask for some languages or content types.


*** Encryption and caching
Because of its statelessness HTTP is easy to combine with encryption and caching. For encryption the by far most frequent way is HTTP over Secure Sockets Layer (SSL) or Transport Layer Security (TLS). From the perspective of the HTTP protocol this encryption is transparent.

For caching, HTTP foresees a set of explicit HTTP headers for this purpose:

- ~Last-Modified~: Indicates when the resource was last changed. This is typically retrieved with a cheap ~HEAD~ request. If ~Last-Modified~ is newer than the latest cached version, the cache should be updated accordingly
- ~ETag~: A response header to enable cache validation

The details of cache handling are beyond this script, cf. {Fielding:1999ub}, chapter 13 for all the details. There are a number of Open Source and proprietary caching solution out there including Squid (http://www.squid-cache.org/), Varnish Cache (https://www.varnish-cache.org/about) and many others. In modern architectures, very often also Non-SQL databases are used for this prupose.

*** Command line tools such as curl and wget
~curl~ (http://curl.haxx.se/) is a standard tool to download websites via the command line or (through ~libcurl~) programmatically:
#+BEGIN_EXAMPLE
curl -v -L -H "Host:www.budabe.eu" -H "Accept:application/xhtml+xml,text/html;q=1.0,text/xml;q=0.9" -H "Accept-Language:de" "http://www.budabe.eu/research"
#+END_EXAMPLE

will return the German-language version of the webpage ~http://www.budabe.eu/research~, with preference in XHTML. The following command, in turn, will return the English language representation:

#+BEGIN_EXAMPLE
curl -v -L -H "Host:www.budabe.eu" -H "Accept:application/xhtml+xml,text/html;q=1.0,text/xml;q=0.9" -H "Accept-Language:en" "http://www.budabe.eu/research"
#+END_EXAMPLE

~wget~ (http://www.gnu.org/software/wget/) has similar functionalities, though more targeted towards web crawling.

** Design principles for RESTful systems


RESTful systems are, as the name suggests, systems on Representational State Transfer. This hints at Fielding's key idea in his famous dissertation is to see the entire web as a single monstrous state machine --- "Hypermedia as the engine of application state" ---, operated by "uniform interface between components" ({Fielding:2000vh}, 5.1.5). The web centres on resources --- "any information that can be named" (5.2.1.1) --- that are uniquely identified by URIs. A resource is in principle independent of its concrete representation, e.g. as HTML or pdf. Clients and server can use content negoation to mutually agree on a suitable representation of a resource. Hence, "REST-based architectures communicate primarily through the transfer of representations of resources" (5.3.3). 

In this concept application state is "the state that the server needs to maintain between each request for each client" ({Allamaraju:2010ty}, p. 7). References to application state or indeed at time the application state itself is coded into URIs and sent with the representation to link to new application states.

A Resource Oriented Architecture (ROA) is "an arrangement of URIs, HTTP, and XML that works like the rest of the Web, and that programmers will enjoy using" ({Richardson:2007td}, chapter 4), the term being coinded as an antithesis to Service Oriented Architectures (SOAs). ROAs embrace RESTful principles and systematize key ideas. 

A ROA is characterized by the key tenents of RESTful systems, i.e.:

- Addressable: each resource is addresable through a URI
- Stateless: each HTTP request standard for itself. It contains all information that the server needs to process the request (it can change the server's resource state, though)
- Links: Links point to possible new states of this or another application
- Uniform interface, i.e. the HTTP methods (polymorphism of HTTP methods, {Dillon:2007hb})



** Assignment
1. Pick a website of your choice and download it using curl. Execute then DELETE, PUT and POST requests with ~curl~
2. In. a programming language of your choice, write a program or script that sends a GET request to that website. Your program must not call ~curl~ or ~wget~

Hand in the assignment via the course's Moodle page.

* Excursion: Clojure and JVM
Session <2012-10-06 Sat>


** Why Clojure?
Clojure is a Lisp for the JVM, the Java platform. It combines the advantages of Lisp, notably its flexible and clean syntax, with full interoperability with existing Java libraries and excellent support for concurrent programming. 

At here two ultimatively simple examples:
#+BEGIN_EXAMPLE
user=> (+ 1 1)
2
user=> (println "Hello World!")
Hello World!
nil
user=> 
#+END_EXAMPLE

Like other Lisps Clojure employs prefix notation for function calls. Things like ~+~ that in other languages are separate operators are ordinary functions, following the same logic as any other function. In the case of ~+~ we have what is called a /pure/ function that does not produce side-effects. The ~println~ in turn does not return anything useful --- though it does return something, the value ~nil~ ---, but it triggers a side action, namely to print out a string on the console.

Before we elaborate more on the advantages let's have a look at some slightly more complex Clojure code (example inspired by , p.3):

#+BEGIN_EXAMPLE
user=> (defn all-lower? [s] (every? #(Character/isLowerCase %) s))
#'user/all-lower?
user=> (all-lower? "aBc")
false
user=> (all-lower? "abc")
true
#+END_EXAMPLE

This short code defines boolean function --- a predicate --- with one parameter using ~defn~. This function checks if all characters in a string are lower-case. It works by just checking if another predicate, -Character/isLowerCase- is true for every character in the string. If so, it returns ~true~, otherwise ~false~.

Already this example is a typical use of functions that themselves call functions (higher-order functions). We can, however, use this function in turn in a larger context, e.g. to filter all all-lower-case strings from a list of strings
#+BEGIN_EXAMPLE
user=> (filter all-lower? '("aBc" "deF" "hij" "Klm" "nop" "QRS" "tuV" "WXy" "z"))
("hij" "nop" "z")
user=> 
#+END_EXAMPLE

That code demonstrates two things:
- Combination of functions allows for a highly declarative style of programming. The above code ready almost like an instruction in ordinary language: filter all strings from this list of string that are in all lower case
- Like all Lisps Clojure follows a philosophy of "code is data", i.e. there are no structural differences between Lisp code and data structures (everything look structurally the same). This principle is known as homoiconicity.

Function definitions can be more complex in that you can have multiple set of parameters, in the following case none (case -[]-), one (case -[name]-) and two (case -[phrase name]):
#+BEGIN_SRC clojure
(defn hello
  ([]
     (hello "Hello" "World"))
  ([name]
     (hello "Hello" name))
  ([phrase name]
     (str phrase ", " name)))
#+END_SRC

Based on the parameters given the right function is chosen:

#+BEGIN_EXAMPLE
user=> (hello)
"Hello, World"
user=> (hello "Worms")
"Hello, Worms"
user=> (hello "Hallo" "Worms")
"Hallo, Worms"
user=> 
#+END_EXAMPLE




On this basis we can now look at some more of the advantages:

- Elegant and concise syntax
- Largely immutable data structures
- Excellent support for concurrent programming
- Close JVM integration

Recommended reading: {Halloway:2012ta}

** Practicalities
*** Installation and integration with Emacs
1. Download leiningen 2.0

Download from http://leiningen.org/

#+BEGIN_EXAMPLE
  wget https://raw.github.com/technomancy/leiningen/preview/bin/lein

  chmod 755 lein

  ./lein self-install
#+END_EXAMPLE

then move lein to a place in the PATH

2. Install package manager

Only for Emacs 23: 

Install the Marmalade package manager

#+BEGIN_EXAMPLE
(require 'package)
(add-to-list 'package-archives
             '("marmalade" . "http://marmalade-repo.org/packages/"))
(package-initialize)
#+END_EXAMPLE

3. Install clojure-mode

https://github.com/technomancy/clojure-mode

4. Install nrepl

https://github.com/kingtim/nrepl.el

M-x package-install [RET] nrepl [RET]

Configure in .emacs:
#+BEGIN_SRC
(require 'package)
(add-to-list 'package-archives
             '("marmalade" . "http://marmalade-repo.org/packages/") t)
(add-to-list 'package-archives
             '("melpa" . "http://melpa.milkbox.net/packages/") t)
(package-initialize)

(require 'clojure-mode) ;;https://github.com/technomancy/clojure-mode/blob/master/clojure-mode.el

(setq inferior-lisp-program "lein repl")
(setq clojure-swank-command ;; https://github.com/pallet/ritz/tree/develop/swank
  (if (or (locate-file "lein" exec-path) (locate-file "lein.bat" exec-path))
    "lein ritz-in %s"
    "echo \"lein ritz-in %s\" | $SHELL -l"))
#+END_SRC

5. Start nrepl

M-x nrepl-jack-in

For Eclipse users there is the Counterclockwise plugin that can be used instead (http://code.google.com/p/counterclockwise/). For installation instructions see there.

*** Leiningen
Leiningen (http://leiningen.org) is the standard tool for managing dependencies for Clojure. It builds on the standard Java tool for this purpose, Maven, but adds a much more simpler syntax to express dependencies.

Like Maven projects Leiningen projects have a predefined directory structure:

#+BEGIN_EXAMPLE
project/src            Source code
       /test           Unit tests
       /project.clj    Dependency file
#+END_EXAMPLE

Project files with the dependency structure just list the packages and their desired versions:

#+BEGIN_SRC clojure
(defproject eu.budabe/eli-project "0.1" 
  :dependencies [[org.clojure/clojure "1.4.0"]
                 [clj-http "0.5.3"]
                 [cheshire "4.0.2"]
                 [org.clojure/data.zip "0.1.0"]])
#+END_SRC

Leiningen itself will then automatically download the necessary libraries and install them as necessary. Much like Python, Perl and Ruby Clojure has a universally accepted central repository http://clojars.org which hosts Clojure libraries. In addition, all "normal" Java libraries can also be used.

Leiningen itself has a number of options, most of which are self-explanatory.

#+BEGIN_EXAMPLE
marcwilhelmkuster$ lein --help
Leiningen is a tool for working with Clojure projects.

Several tasks are available:
check               Check syntax and warn on reflection.
classpath           Write the classpath of the current project to output-file.
clean               Remove all files from project's target-path.
compile             Compile Clojure source into .class files.
deploy              Build jar and deploy to remote repository.
deps                Show details about dependencies.
do                  Higher-order task to perform other tasks in succession.
help                Display a list of tasks or help for a given task.
install             Install current project to the local repository.
jar                 Package up all the project's files into a jar file.
javac               Compile Java source files.
new                 Generate project scaffolding based on a template.
plugin              DEPRECATED. Please use the :user profile instead.
pom                 Write a pom.xml file to disk for Maven interoperability.
repl                Start a repl session either with the current project or standalone.
retest              Run only the test namespaces which failed last time around.
ritz                Launch ritz server for Emacs to connect.
ritz-in             Jack in to a ritz backed Clojure SLIME session from Emacs.
run                 Run the project's -main function.
search              Search remote maven repositories for matching jars.
show-profiles       List all available profiles or display one if given an argument.
test                Run the project's tests.
trampoline          Run a task without nesting the project's JVM inside Leiningen's.
uberjar             Package up the project files and all dependencies into a jar file.
upgrade             Upgrade Leiningen to specified version or latest stable.
version             Print version for Leiningen and the current JVM.
with-profile        Apply the given task with the profile(s) specified.

Run lein help $TASK for details.

Aliases:

See also: readme, faq, tutorial, news, sample, profiles,
deploying and copying.
#+END_EXAMPLE

~lein repl~ starts a Clojure command shell with all dependencies loaded:
#+BEGIN_EXAMPLE
marcwilhelmkuster$ lein repl
nREPL server started on port 55766
REPL-y 0.1.0-beta10
Clojure 1.4.0
    Exit: Control+D or (exit) or (quit)
Commands: (user/help)
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
          (user/sourcery function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
Examples from clojuredocs.org: [clojuredocs or cdoc]
          (user/clojuredocs name-here)
          (user/clojuredocs "ns-here" "name-here")
user=> (+ 1 1)
2
user=> (defn all-lower? [s] (every? #(Character/isLowerCase %) s))
#'user/all-lower?
user=> (all-lower? "aBc")
false
user=> (all-lower? "abc")
true
user=> 
#+END_EXAMPLE

~lein new PROJECT~ creates a new empty project structure with placeholders for all important files:

#+BEGIN_EXAMPLE
$ lein new b5
Generating a project called b5 based on the 'default' template.
To see other templates (app, lein plugin, etc), try `lein help new`.
$ cd b5
$ find . -name "*"
.
./.gitignore
./doc
./doc/intro.md
./project.clj
./README.md
./src
./src/b5
./src/b5/core.clj
./test
./test/b5
./test/b5/core_test.clj
$ 
#+END_EXAMPLE

The Leiningen tutorial https://github.com/technomancy/leiningen/blob/master/doc/TUTORIAL.md illustrates all possible operations in detail.

*** Syntax and data structures
We have already seen examples of Clojure's syntax. Function calls are of the type:
#+BEGIN_EXAMPLE
user=> (function-name params listed)
#+END_EXAMPLE


Defining new functions is as simple:
#+BEGIN_SRC clojure
(defn all-lower? [s] (every? #(Character/isLowerCase %) s))
#+END_SRC

In total the following primitive data structures exist in Clojure:
#+BEGIN_EXAMPLE
Boolean: true | false
Character: \a \b \c
String: "abc"
List: ("a" "b" "c") (all-lower? "abc")
Map: {:key1 "Value1", :key2 "Value2"}
Number: 1.23
Set: #{ 1 2 3}
Vector: [1 2 3]

Symbol: eli/build-act
Keywords: :keyword :name
Nil: nil
#+END_EXAMPLE

**** Lists
Lisps are famous for using lists. In Clojure lists are also key to the syntax, but not anywhere as strongly as in classical Lisps.

#+BEGIN_EXAMPLE
user=> (list 1 2 3)
(1 2 3)
user=> (list 1 2 "a" "b")
(1 2 "a" "b")
user=> '(1 2 "a" "b")
(1 2 "a" "b")
user=> (quote (1 2 "a" "b"))
(1 2 "a" "b")
user=> (list 1 2 (+ 3 4))
(1 2 7)
user=> '(1 2 (+ 3 4))
(1 2 (+ 3 4))
user=> 
#+END_EXAMPLE

As we have seen, also function calls are lists:
#+BEGIN_EXAMPLE
user=> (all-lower? "abc")
true
#+END_EXAMPLE


**** Vectors
Vectors are Clojure's equivalent to arrays. They are indexed, indexes can be used to address individual elements in the vector.
#+BEGIN_EXAMPLE
user=> [1 2 3]
[1 2 3]
user=> (def v [1 2 3])
#'user/v
user=> (vector? v)
true
user=> (v 1)
2
user=> 
user=> [1 2 "a" "b"]
[1 2 "a" "b"]
user=> 
#+END_EXAMPLE

Vectors themselves can be used as functions, taking the relevant index as a parameter.

**** Maps
Maps are very much the bread and butter data structure in Clojure and are used to model flexible data structures:

#+BEGIN_EXAMPLE
user=> {:first-name "Marc", :last-name "Kuester"}
{:last-name "Kuester", :first-name "Marc"}
user=> (def kuester {:first-name "Marc", :last-name "Kuester"})
#'user/kuester
user=> (:last-name kuester)
"Kuester"
user=> 
#+END_EXAMPLE

Using the comma to separate key-value-pairs is optional. All data structures can be used as as keys, though keywords are the most common case. Keywords can also be used as functions, they return the value corresponding to this key in the map.

**** -defrecord-
In addition, you can easily define new data structures in the form of records:
#+BEGIN_EXAMPLE
user=> (defrecord Teacher [first-name last-name office-no])
user.Teacher
user=> (->Teacher "Marc" "Kuester" 123)
#user.Teacher{:first-name "Marc", :last-name "Kuester", :office-no 123}
user=> (:first-name (->Teacher "Marc" "Kuester" 123))
"Marc"
user=> 
#+END_EXAMPLE


** Control structures
Clojure has at its core only very simple comtrol structures: ~if~, ~do~ and ~loop~. Of these, however, you use only ~if~ regularly and directly:

#+BEGIN_EXAMPLE
user=> (defn all-lower? [s] (every? #(Character/isLowerCase %) s))
user=> (if (all-lower? "abc") "all lower case" "also capital letters")
"all lower case"
user=> 
#+END_EXAMPLE

The first branch is used if the condition is true ("then-branch"), the second one if it is false ("else-branch"). Incidentally, if is a function like all other functions, returning the then or else branch as the case may be.

#+BEGIN_EXAMPLE
user=> (def a (if (all-lower? "abc") "all lower case" "also capital letters"))
#'user/a
user=> a
"all lower case"
user=> (def b (if (all-lower? "aBc") "all lower case" "also capital letters"))
#'user/b
user=> b
"also capital letters"
user=> 
#+END_EXAMPLE

~do~ is needed if for some reason more than one action is needed in the then or else branch. By necessity, these other actions are defined by their side effect:
#+BEGIN_EXAMPLE
user=>  (if (all-lower? "aBc") (do (println "then") "all lower case") (do (println "else") "also capital letters"))
else
"also capital letters"
user=> 
#+END_EXAMPLE


~loop~ is hardly ever used directly. Here an example of a loop that calculates the squares of all even numbers:
#+BEGIN_SRC clojure
;;very complicated, do not use
(loop [lst '(1 2 3 4 5 6) res '()]  
(let [l (last lst)]
(if (empty? lst)
  res
  (recur (drop-last lst) (if (even? l) (cons (* l l) res) res)))))
#+END_SRC

As usual for Lisps these primitive control structures are replaced by more powerful abstractions built on top of these basic building blocks. These include ~for~ and ~when~. ~for~, however, has little in common with a for-loop in, say, C. Ui stead it is a close parent of the list comprehensions that exist e.g. in Python:

#+BEGIN_EXAMPLE
user=> (for [i '(1 2 3 4 5 6) :when (even? i)] (* i i))
(4 16 36)
user=> 
#+END_EXAMPLE

Really, the use of explicit control structures is much rarer in Clojure than in traditional imperative languages. Instead, higher-order functions operating on sequences are the bread and butter of Clojure ans indeed of functional programming in general.

So, instead of using the above idiom to output the squares of even numbers a even more idiomatic approach would be:

#+BEGIN_EXAMPLE
user=> (map (fn [i] (* i i)) (filter even? '(1 2 3 4 5 6)))
(4 16 36)
user=> 
#+END_EXAMPLE

or even shorter

#+BEGIN_EXAMPLE
user=> (map  #(* % %) (filter even? '(1 2 3 4 5 6)))
(4 16 36)
user=> 
#+END_EXAMPLE

This makes usually for much clearer code.

** Lazy sequences
However, Clojure still has a surprise  in petto. In contrast to most other languages it does not only know finite, but also infinite sequences. With this we can find a much more flexible definition for our squares of even numbers, one that does not only work for a given finite list '(1 2 3 4 5 6), but for any type of range:
#+BEGIN_EXAMPLE
user=> (defn even-squares [] (map #(* % %) (filter even? (range))))
#'user/even-squares
user=> (take 10 (even-squares))
(0 4 16 36 64 100 144 196 256 324)
user=> (take 50 (even-squares))
(0 4 16 36 64 100 144 196 256 324 400 484 576 676 784 900 1024 1156 1296 1444 1600 1764 1936 2116 2304 2500 2704 2916 3136 3364 3600 3844 4096 4356 4624 4900 5184 5476 5776 6084 6400 6724 7056 7396 7744 8100 8464 8836 9216 9604)
user=> 
#+END_EXAMPLE

or even shorter

#+BEGIN_EXAMPLE
user=> (defn even-squares [] (map #(* % %)  (range 0 Double/POSITIVE_INFINITY 2)))
#'user/even-squares
user=> (take 10 (even-squares))
(0 4 16 36 64 100 144 196 256 324)
user=> 
#+END_EXAMPLE


This may look rather surprising --- how can a language treat infinite sequences? This only works because Clojure treats these sequences as so-called lazy sequences that are instantiated --- realized is the term --- only when really used. So, before we actually take the first 10 squares, nothing is calculated. Only the moment that we really want to print those 10 and then in a second round 50 squares are they really calculated. Results that are no longer needed can be garbage collected.

Lazy sequences make for elegant code also for finite, but potentially large sequences. Results of database queries can be of considerable size and often necessitate paging to treat batches of results one after the other. Lazy sequences can abstract from this detail without loading all results into memory. 

** Assignment
1. Write a clojure program that takes a list of strings and returns another list of only those strings that start with the character "a", but uppercased. So, e.g. for an input '("xyz" "cde" "abc" "bab" "axx") it should return '("ABC" "AXX"). Write first a unit test and then the function and run lein test to prove it works.
2. Write the same program in another programming language of your choice

Hand in assignment via the course's Moodle page.


** Principles of functional programming
Session <2012-10-19 Fri>

Functional programming centres around a number of key principles that are more or less "purely" realized in the various functional languages:

  - Immutable data
  - Functions as data
  - Pure Functions
  - Higher-Order Functions
  - Use of recursion

We have seen cases of function as data and higher order functions. These are key to all functional languages and especially to Clojure. Clojure also has a strong preference for pure functions, i.e. functions that have no side-effects and always return the same output for the same input. 

The example of the "square of even numbers" functions is built on functions as data (~even?~, ~#(* % %)~ etc.) that are parameters to higher-order functions (~filter~, ~map~). All of these functions are pure in a mathematical sense.
#+BEGIN_SRC clojure
(map  #(* % %) (filter even? '(1 2 3 4 5 6)))
#+END_SRC 

Clojure is less oriented towards explicit recursion as other languages such as Scheme, but they still play an important role. However, the concept of immutable data is at the core of Clojure. All the data structures that we have seen are immutable (and many are in addition lazy). Of course, it is still possible to handle mutable data, and in fact Clojure offers some powerful strategies to handle data updates in transactions (Software Transactional Memory or STM). Transactional references (Refs) make for safe mutable data. However, a detailed discussion of this is out of scope for this session.

More information on Clojure and its API is available under http://clojure.org/ and http://clojuredocs.org/






** Futures
For long-running calculations Clojure has the concept of futures (http://clojuredocs.org/clojure_core/clojure.core/future). A future is calculated in a separate thread, but transparently to the user:

#+BEGIN_SRC clojure
(defn get-page [host port]
  (let
      [conn (Socket. host port)
       in (.getInputStream conn)
       out (.getOutputStream conn)]
    (write-request out host)
    (future (read-response in))))
#+END_SRC 

Assuming that ~read-response~ takes a considerable time to execute and would block further program execution for the time it takes, ~(future (read-response in))~ returns instead a /promise/ to the real value that it will contain. Once the calculation is complete, it will be transparently replaced by the final value, without blocking the current execution:

#+BEGIN_EXAMPLE
user> (def p (get-page "www.google.de" 80))
GET / HTTP/1.1
Host: www.google.de

Request written
#'user/p
user> p
#<core$future_call$reify__6110@2ca275d8: :pending>
user> 
user> p
#<core$future_call$reify__6110@2ca275d8: :pending>
user> @p
[now execution blocks until the page is fully retrieved]
#+END_EXAMPLE

If you need the guarantee to have the value at a later stage, you can dereference the future by using the ~@~ reader macro, e.g. ~@p~. In this case program execution will block until the correct value is calculated, if that is not yet the case.

** Multimethods: Polymorphism functional style

Clojure has no native concept of objects (it does have an object concept for interfacing with Java). Instead, it offers named data structures --- records --- as well as functions that can dispatch on them and indeed on many other criteria. In the simplest of cases we have 

#+BEGIN_SRC Clojure

(defrecord Variable [text postfix])

(defrecord Token [variables prefix])

(defmulti handle-value 
  "Handling of individual variables. Returns the variable replaced by the supplied values"
  (fn [^Variable variable values separator encoding-fn]
    (class (values (:text variable)))))

(defmethod handle-value String [^Variable variable values separator encoding-fn]
 ;one strategy for strings
)

(defmethod handle-value java.util.Collection [^Variable variable values separator encoding-fn]
 ; another strategy to handle collections
)
; and so on
#+END_SRC

In the most frequent case dispatching is by data type or class, but it can be by anything else. ~defmulti~ defines in its implementation the strategy to be chosen by the individual ~defmethod~.

* Programming RESTful Web Services
  

In our first session we've learned about the HTTP protocol as the technical underpinning for RESTful Web Services. In fact, on the protocol level RESTful Web Services just operate HTTP request / response pairs, using the full set of HTTP methods. In this second phase we're going into more details on other aspects of the design of RESTful Web Services as well as the "RESTful" philosophy. Afterwards we will actually write some Clojure programs to test this out.

** Design of URIs
Maybe the most overlooked aspect of RESTful Web Services is the need for "cool URIs". "A cool URI is one which does not change" ({BernersLee:1998ui}):
#+BEGIN_QUOTE
It is the the duty of a Webmaster to allocate URIs which you will be able to stand by in 2 years, in 20 years, in 200 years. This needs thought, and organization, and commitment.
#+END_QUOTE

Berners-Lee proposes that a good URI must remain stable over time. For this it should leave out of the URIs:
- Author's names
- Subject classifications
- Status information (old, new etc.)
- Access rights
- File name extensions
- Implementation details (e.g. ~/cgi-bin/~ or similar)

Instead, he proposes to use stable information such as the original creation date. 

For URIs referring to real-life objects such as persons, {Anonymous:2008vd}, 4.5 proposes to follow three design goals:
- Simplicity
- Stability
- Manageability

*** URI Templates
Remains the question on how to transpose these principles into concrete URIs and how to document the resulting URI patterns. RFC 6570 "URI templates" (http://tools.ietf.org/html/rfc6570 / {Gregorio:2012vo}) defines a template language to document and automatically fill URI templates. The specification defines four levels of compliance. At its simplest, URI templates define string substitutions (compliance level 1):

#+BEGIN_EXAMPLE
http://www.budabe.eu/{section}/{subsection}

section := "research"
subsection := "DigitalHumanities"

-->
http://www.budabe.eu/research/DigitalHumanities
#+END_EXAMPLE

If necessary, strings are URI encoded, e.g. ~http://www.budabe.eu/research/Digital%20Humanities~ if ~subsection := Digital Humanities~. Variables can occur both at the level of URIs and query parameters.

Level 2 adds handling of reserved characters that would otherwise be URI encoded. You achieve this goal by adding a ~+~ as the first character of the variable:
#+BEGIN_EXAMPLE
http://www.budabe.eu/{section}
section := "research/Digital Humanities"
-->
http://www.budabe.eu/research%2FDigital%20Humanities

but

http://www.budabe.eu/{+section}
section := "research/Digital Humanities"
-->
http://www.budabe.eu/research/Digital%20Humanities
#+END_EXAMPLE

Similarly, if the first character is a hash (~#~), the resulting string contains the hash:

#+BEGIN_EXAMPLE
http://www.budabe.eu/{#section}
section := "Digital Humanities"
-->
http://www.budabe.eu/#Digital%20Humanities
#+END_EXAMPLE

Level 3 add "multiple variables per expression, each separated by a comma, and add more complex operators for dot-prefixed labels, slash-prefixed path segments, semicolon-prefixed path parameters, and the form-style construction of a query syntax consisting of name=value pairs that are separated by an ampersand character" (RFC 6570, p. 5):

#+BEGIN_EXAMPLE
http://www.budabe.eu/{+section,subsection}
section := "research"
subsection := "Digital Humanities"
-->
http://www.budabe.eu/research,Digital%20Humanities
#+END_EXAMPLE

Similarly, if the first character is a ~/~, the template is treated as a path (and, in the case of ~#~ as an anchor):

#+BEGIN_EXAMPLE
http://www.budabe.eu{/section,subsection}       
(note that there is no slash behind .eu)
section := "research"
subsection := "Digital Humanities"
-->
http://www.budabe.eu/research/Digital%20Humanities
#+END_EXAMPLE

If a part of the variables are not given for substitution, the corresponding part is just left out:
#+BEGIN_EXAMPLE
http://www.budabe.eu{/section,subsection}       
section := "research"
-->
http://www.budabe.eu/research

http://www.budabe.eu{/section,subsection}       
subsection := "Digital Humanities"
-->
http://www.budabe.eu/Digital%20Humanities
#+END_EXAMPLE

The same applies if the first character is a ~?~ or ~&~, in which case all arguments are treated as query string parameters. 

Level 4 adds the ability to slighly modify values during variable substitution by adding a ~:~ at the end:
#+BEGIN_EXAMPLE
http://www.budabe.eu{/section:4}
section := "research"
-->
http://www.budabe.eu/rese
#+END_EXAMPLE

Likewise, a ~*~ at the end permits the handling of multiple values in lists or similar:

#+BEGIN_EXAMPLE
http://www.budabe.eu/{section*}
section := ("research", "Digital Humanities")
-->
http://www.budabe.eu/research,Digital%20Humanities
#+END_EXAMPLE

Pre- and postfix modifiers can be combined:

#+BEGIN_EXAMPLE
http://www.budabe.eu{/section*}
section := http://www.budabe.eu{/section*}
--> 
http://www.budabe.eu/research/Digital%20Humanities
#+END_EXAMPLE

RFC 6570 also has a semi-official test suite https://github.com/uri-templates/uritemplate-test. The examples given in this test suite help to understand many of the edge cases.

*** The case of the European Legislation Identifier (ELI)
The European Legislation Identifier (ELI / http://register.consilium.europa.eu/pdf/en/12/st13/st13401.en12.pdf, cf. also http://europa.eu/rapid/pressReleasesAction.do?reference=IP/12/1040&format=HTML&aged=0&language=EN&guiLanguage=en), published as a Council Conclusions 13401/12,  is a scheme to express laws through URIs. Every member state can flexibly express their own online resources for legislation, however using common variables that can be used to build concrete URI templates. The following variables are in principle foreseen:

#+BEGIN_EXAMPLE
{jurisdiction} {agent} {sub-agent} {year} {month} {day } {type} {natural identifier} {level 1…} {point in time} {version} {language}
#+END_EXAMPLE

The semantics of these template components is well defined within the Council Conclusions (cf. p. 9).

Concrete URI templates for European Legislation can look like this:

#+BEGIN_EXAMPLE
http://eurlex.europa.eu/eli{/type}{/agent*}{/year}{/natural_identifier,version,language}
#+END_EXAMPLE

The type of legislation is in this case identified by a language-independent code, e.g. ~reg~ for ~regulation~ or ~dir~ for directive. Likewise, ~agent~ can be the code for zero to many actors in the European legislative process, e.g. ~ep~ for the European Parliament or ~consil~ for the Council of the European Union. ~year~ is the year in which the legislation was passed and the natural identifier is typically a running number given to a specific type of legislation. The optional ~version~ can identify if this specific act is a corrigendum, e.g. ~R1~. ~language~ optionally identifies a language version of an act.

So, for the Public Sector Information Directive 2003/98/EC of the European Parliament and of the Council of 17 November 2003 in English the ELI would be as follows:

#+BEGIN_EXAMPLE
http://eurlex.europa.eu/eli{/type}{/agent*}{/year}{/natural_identifier,version,language}

type := "dir"
agent := ("ep", "consil")
year := 2003
natural_identifier := 98
language := "ENG"
-->
http://eurlex.europa.eu/eli/dir/ep/consil/2003/98/ENG
#+END_EXAMPLE

The third corrigendum of the same act in Spanish has the ELI:
#+BEGIN_EXAMPLE
http://eurlex.europa.eu/eli{/type}{/agent*}{/year}{/natural_identifier,version,language}

type := "dir"
agent := ("ep", "consil")
year := 2003
natural_identifier := 98
version := "R3"
language := "SPA"
-->
http://eurlex.europa.eu/eli/dir/ep/consil/2003/98/R3/SPA
#+END_EXAMPLE

ELIs follow a logic of search: individual legal resources have metadata elements such as ~type~ or ~agent~, an ELI identifies the resource that corresponds to that combination of metadata. By construction, there is maximally one such resource.

This logic, however, generalizes also to URI templates that identify a set of resources, e.g.:

All legal resources of a given type in a year with its natural identifier regardless of their creating agent:

#+BEGIN_EXAMPLE
http://eurlex.europa.eu/eli{/type}{/year}{/natural_identifier,version,language}
#+END_EXAMPLE

All legal resources of a given type in a given year:

#+BEGIN_EXAMPLE
http://eurlex.europa.eu/eli{/type}{/year}
#+END_EXAMPLE

All legal resources of a given type:

#+BEGIN_EXAMPLE
http://eurlex.europa.eu/eli{/type}
#+END_EXAMPLE

All legal resources in a given year regardless of its type:

#+BEGIN_EXAMPLE
http://eurlex.europa.eu/eli{/year}
#+END_EXAMPLE

And finally all legal resources of a given type from one or more given agents:
#+BEGIN_EXAMPLE
http://eurlex.europa.eu/eli{/type}{/agent*}
#+END_EXAMPLE

*** Handling URITemplates in Clojure

The URITemplates implementation in Clojure, ~uritemplates-clj~ (https://github.com/mwkuster/uritemplate-clj), that I have prepared for this purpose has an extremely simple interface. It exposes a single method, ~uritemplate~, taking the URI template and a map of values as input and returning the URI with the filled in template:

#+BEGIN_EXAMPLE
user=> (ns test
  #_=> (:require [uritemplate-clj.core :as templ]))
nil
test=> (templ/uritemplate "http://example.org/abc{/type}{/agent*}{/year}{/natural_identifier,version,language}" {"type" "dir", 
  #_=>                "agent"  ["ep" "consil"], 
  #_=>                "year"  "2003",
  #_=>                "natural_identifier" "98"})
"http://example.org/abc/dir/ep/consil/2003/98"
test=> 
#+END_EXAMPLE

** JSON and cheshire
The JavaScript Object Notation or JSON (=
http://tools.ietf.org/html/rfc4627) at its simplest is just a subset
of JavaScript concerning only data. JSON uses UTF-8 and supports the
usual datatypes: "A JSON value MUST be an object, array, number, or
string, or one of the following three literal names: false null true" (2.1). Concretely, the following types exist (description follows RFC 4627):


- Number: an integer component that   may be prefixed with an optional minus sign, which may be followed by  a fraction part and/or an exponent part. Octal and hex forms are not allowed.  Leading zeros are not allowed
- String: string begins and ends with  quotation marks.  All Unicode characters may be placed within the   quotation marks except for the characters that must be escaped:   quotation mark, reverse solidus, and the control characters (U+0000   through U+001F). The string is encoded in UTF-8
- Boolean: true or false
- Array: square brackets surrounding zero or more values (or elements).  Elements are separated by commas
- Object: a pair of curly brackets   surrounding zero or more name/value pairs (or members).  A name is a   string.  A single colon comes after each name, separating the name   from the value. 
- null (empty)

We see many of these in action in the following extract taken from https://github.com/uri-templates/uritemplate-test/blob/master/extended-tests.json:

#+BEGIN_SRC JavaScript
{
    "Additional Examples 1":{
        "level":4,
        "variables":{
            "id"           : "person",
            "token"        : "12345",
            "fields"       : ["id", "name", "picture"],
            "format"       : "json",
            "q"            : "URI Templates",
            "page"         : "5",
            "lang"         : "en",
            "geocode"      : ["37.76","-122.427"],
            "first_name"   : "John",
            "last.name"    : "Doe", 
            "Some%20Thing" : "foo",
            "number"       : 6,
            "long"         : 37.76,
            "lat"          : -122.427,
            "group_id"     : "12345",
            "query"        : "PREFIX dc: <http://purl.org/dc/elements/1.1/> SELECT ?book ?who WHERE { ?book dc:creator ?who }",
            "word"         : "drücken",
            "Stra%C3%9Fe"  : "Grüner Weg",
            "random"       : "šöäŸœñê€£¥‡ÑÒÓÔÕÖ×ØÙÚàáâãäåæçÿ",
            "assoc_special_chars"  :
              { "šöäŸœñê€£¥‡ÑÒÓÔÕ" : "Ö×ØÙÚàáâãäåæçÿ" }
        }
}
#+END_SRC

For many languages and especially for dynamic languages JSON maps directly into the corresponding language structures. In Clojure the internal representation of this objects looks very similar to the JSON original and that's certainly no coincidence:

#+BEGIN_SRC Clojure
{"Additional Examples 1"
 {"level" 4, "variables" 
   {"random" "šöäŸœñê€£¥‡ÑÒÓÔÕÖ×ØÙÚàáâãäåæçÿ", 
   "last.name" "Doe", 
   "query" "PREFIX dc: <http://purl.org/dc/elements/1.1/> SELECT ?book ?who WHERE { ?book dc:creator ?who }",
   "number" 6, 
   "word" "drücken", 
   "assoc_special_chars" {"šöäŸœñê€£¥‡ÑÒÓÔÕ" "Ö×ØÙÚàáâãäåæçÿ"},
   "lang" "en", 
   "page" "5", 
   "q" "URI Templates", 
   "format" "json", 
   "Stra%C3%9Fe" "Grüner Weg", 
   "token" "12345", 
   "fields" ["id" "name" "picture"], 
   "first_name" "John", 
   "id" "person", 
   "group_id" "12345", 
   "long" 37.76, 
   "geocode" ["37.76" "-122.427"], 
   "lat" -122.427, 
   "Some%20Thing" "foo"
   } 
 }
}
#+END_SRC

Incidentally, the order of attributes in an object is undefined.

There are a number of Clojure libraries for JSON handling. The one we use here is Cheshire (https://clojars.org/cheshire), build on the Open Source Java Jackson library (http://wiki.fasterxml.com/JacksonHome). It is extremely easy to use:

#+BEGIN_SRC Clojure
(ns b5
  (:use [cheshire.core]))

(def extended-tests  
 (cheshire.core/parse-stream 
    (clojure.java.io/reader "test/uritemplate_clj/extended-tests.json")))
#+END_SRC

Similarly, Cheshire can easily map native Clojure maps to JSON:

#+BEGIN_SRC Clojure
(ns b5
  (:use [cheshire.core]))

(cheshire.core/generate-string {:a  "b", :b 5, "c" [1 2 3 4 5]})
-->
"{\"c\":[1,2,3,4,5],\"a\":\"b\",\"b\":5}"
#+END_SRC

** Assignment 
Take at your choice and depending on your language skills one of the websites

- http://www.legilux.public.lu/  (Luxembourg, in French)
- http://legimobile.fr/ (France)
- http://www.belgielex.be/ (Belgium, in French, Dutch, German and English, do search in "Législation belge", then check for frame source to see the links)
- http://legislation.gov.uk/  (UK)
- http://www.normattiva.it/ricerca/semplice (Italy)

and define a URI template for it. Test the pattern using the uritemplate-clj library or another URITemplate library of your choice and verify for at least 15 different URIs that the URIs that you generate actually exist.

Hand in via the course's Moodle page the:
- URI pattern defined
- script used to test that pattern
- list of at least 15 URIs generated and subsequently tested


** ATOM and related standards
ATOM / RFC 4287 (= http://www.ietf.org/rfc/rfc4287.txt), which was incidentally created by the same person as the URI template specification, is next to RSS the most popular standard for content syndication. It is at the same time much more popular than RSS for machine-to-machine communication:
#+BEGIN_QUOTE
Atom is an XML-based document format that describes lists of related
information known as "feeds".  Feeds are composed of a number of
items, known as "entries", each with an extensible set of attached
metadata.  For example, each entry has a title.

The primary use case that Atom addresses is the syndication of Web
content such as weblogs and news headlines to Web sites as well as
directly to user agents. (RFC 4287 / {Gregorio:Z8RX-4sN})
#+END_QUOTE

The following extract is taken directly from the RFC:

#+BEGIN_EXAMPLE
<feed xmlns="http://www.w3.org/2005/Atom">
 <title>Example Feed</title>
 <link href="http://example.org/"/>
 <updated>2003-12-13T18:30:02Z</updated>
 <author>
  <name>John Doe</name>
 </author>
 <id>urn:uuid:60a76c80-d399-11d9-b93C-0003939e0af6</id>

 <entry>
  <title>Atom-Powered Robots Run Amok</title>
  <link href="http://example.org/2003/12/13/atom03"/>
  <id>urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a</id>
  <updated>2003-12-13T18:30:02Z</updated>
  <summary>Some text.</summary>
 </entry>
</feed>
#+END_EXAMPLE

ATOM feeds exist for many blogs, often alongside feeds in RSS. For further examples we will use  http://planet.clojure.in/atom.xml, but we could have used any number of other blogs.

#+BEGIN_EXAMPLE
curl http://planet.clojure.in/atom.xml | less
-->

<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Planet Clojure</title>
  <link rel="self" href="http://planet.clojure.in/atom.xml"/>
  <link href="http://planet.clojure.in/"/>
  <id>http://planet.clojure.in/atom.xml</id>
  <updated>2012-10-14T10:15:44+00:00</updated>
  <generator uri="http://www.planetplanet.org/">http://intertwingly.net/code/venus/</generator>
  <entry>
    <title type="html">Presentation: Distributed Apps: The Joys of Testing and Debugging</title>
    <link href="http://www.infoq.com/presentations/Clojure-Stack-Trace"/>
    <id>http://www.infoq.com/presentations/Clojure-Stack-Trace</id>
    <updated>2012-10-12T22:40:00+00:00</updated>
    <content type="html">Chris Houser discusses stack traces in Clojure and introduces a library for investigating activity across multiple threads and servers, plus a technique for reproducing race conditions. &lt;i&gt;By Chris Houser&lt;/i&gt;</content>
    <author>
            <name>Clojure at InfoQ</name>
            <uri>http://pipes.yahoo.com/pipes/pipe.info?_id=be83c0b5b0d92b259682cb8021e14d2a</uri>
    </author>
    <source>
            <title type="html">InfoQ Clojure-related materials</title>
            <subtitle type="html">Pipes Output</subtitle>
            <link rel="self" href="http://pipes.yahoo.com/pipes/pipe.run?_id=be83c0b5b0d92b259682cb8021e14d2a&amp;_render=rss"/>
            <id>http://pipes.yahoo.com/pipes/pipe.info?_id=be83c0b5b0d92b259682cb8021e14d2a</id>
    </source>
  </entry>
  <entry>
        [...]
   </entry>
   [...]
</feed>
#+END_EXAMPLE

ATOM uses the namespace ~http://www.w3.org/2005/Atom~. Some information is provided on the Feed level, notably the feed's title, an identifier (~id~), a link to the Atom feed itself (~link~ with rel="self") and possibly to its website and, most crucially, the last update data ~updated~ that allows a feed reader to decide if it needs to check for added or updated entries without downloading everything. The real content is then inside the individual ~entry~ elements, bringing the entry ~title~, a link to the corresponding web page, again the last ~updated~ timestamp for this entry and a summary (~content~), in this case formatted in basic HTML. Planet Clojure is special in that it is a feed of feeds that aggregates entries from a lot of smaller blogs. For this reason, it indicates the source of that information, together with links and ids.

ATOM is in this paradigmatic for RESTful design. It is transported via HTTP, is both machine and (with suitable readers) human readable and provides links to further pages that the reader, whether a machien or a human, can follow.

*** Rome and ~clj-rome~
"ROME is a set of RSS and Atom Utilities for Java that is open source under the Apache 2.0 license" (https://rometools.jira.com/wiki/display/ROME/Home). It is one of the most popular libraries for handling of (not only) ATOM in the Java world. ~clj-rome~ (https://clojars.org/clj-rome / https://github.com/ngrunwald/clj-rome) is a Clojure wrapper to the ROME library:

#+BEGIN_EXAMPLE
user=> (ns b5 
  #_=> (:require [clj-rome.reader :as rr]))
nil
b5=> (def feed (rr/build-feed "http://planet.clojure.in/atom.xml"))
#'b5/feed
b5=> (keys feed)
(:foreign-markup :published-date :entries :preserving-wire-feed? :copyright :link :contributors :author :supported-feed-types :feed-type :image :language :title :uri :categories :original :modules :interface :links :encoding :authors :title-ex :description :description-ex)
b5=> (count (:entries feed))
40
b5=> (map #(:title %) (:entries feed))
("Presentation: Distributed Apps: The Joys of Testing and Debugging" "Rich Hickey - Podcast Episode 019" "\"Concretely, a Graph is just a Clojure map of functions that can depend on the outputs of other...\"" "Google Common Lisp Style Guide" "Clojure/ClojureScript: One Language to Rule the Web" "No such pipe, or this pipe has been deleted" "codeq" "Writing Datomic in Clojure" "Announcing a new Clojure documentation project" "Stuart Sierra - Podcast Episode 018" "Clojure: Refactoring From Thread Last (-&gt;&gt;) To Thread First (-&gt;)" "Versatile into" "Top 20 Web Frameworks for the JVM" "Replacing Common Code With clojure.set Function Calls" "Clojure: Stages of Enlightenment." "Clojure Gazette 1.23" "Memobot" "All ideas are old ideas" "Announcing Langohr documentation guides" "Creating a glow effect" "clojure: lein tar" "Applying DRY to Editing" "Jay Fields' Thoughts: Clojure: Avoiding Anonymous Functions" "Does Scala as a FP Language Suffer From Its OO Syntax?" "No such pipe, or this pipe has been deleted" "Clojure: Avoiding Anonymous Functions" "HalBuilder 2.0.1 Progress" "More Core.logic" "Prismatic's \"Graph\" at Strange Loop" "Clojure Koans" "Image filtering" "Configuration Files in Clojure" "Functional thinking: Tons of transformations" "Functional thinking: Tons of transformations" "A Crash Course on CTCO" "Ecosystems Are Overrated" "I tried using Twitter Bootstrap this morning. Really nice way to support mobile devices." "Clojure Macro: defn-curried" "Clojure Gazette 1.22" "Some core.logic graph code")
b5=> (first (:entries feed))
{:enclosures [], :foreign-markup [], :wire-entry nil, :published-date nil, :link "http://www.infoq.com/presentations/Clojure-Stack-Trace", :contributors [], :author "Clojure at InfoQ", :title "Presentation: Distributed Apps: The Joys of Testing and Debugging", :uri "http://www.infoq.com/presentations/Clojure-Stack-Trace", :updated-date #inst "2012-10-12T22:40:00.000-00:00", :categories [], :modules [{:subject nil, :creator "Clojure at InfoQ", :date nil, :identifier nil, :formats [], :subjects [], :creators ["Clojure at InfoQ"], :types [], :contributors [], :coverages [], :contributor nil, :language nil, :title nil, :uri "http://purl.org/dc/elements/1.1/", :identifiers [], :rights nil, :rights-list [], :coverage nil, :type nil, :interface com.sun.syndication.feed.module.DCModule, :sources [], :dates [], :format nil, :publishers [], :relations [], :descriptions [], :languages [], :source nil, :relation nil, :titles [], :publisher nil, :description nil}], :interface com.sun.syndication.feed.synd.SyndEntry, :links [{:href "http://www.infoq.com/presentations/Clojure-Stack-Trace", :length 0, :title nil, :type nil, :rel "alternate", :hreflang nil}], :authors [{:name "Clojure at InfoQ", :uri "http://pipes.yahoo.com/pipes/pipe.info?_id=be83c0b5b0d92b259682cb8021e14d2a", :email nil, :modules []}], :title-ex {:type "html", :interface com.sun.syndication.feed.synd.SyndContent, :mode nil, :value "Presentation: Distributed Apps: The Joys of Testing and Debugging"}, :description nil, :contents [{:type "html", :interface com.sun.syndication.feed.synd.SyndContent, :mode nil, :value "Chris Houser discusses stack traces in Clojure and introduces a library for investigating activity across multiple threads and servers, plus a technique for reproducing race conditions. <i>By Chris Houser</i>"}]}
b5=> 
#+END_EXAMPLE

In these examples Clojure returns as usual a map that can be manipulated with the usual higher-order functions. ~:entries~ then contains a sequence of maps with the data for the individual entries.


** Libraries for RESTful web services

Session <2012-10-20 Sat>
- Popular JVM libraries for RESTful web services
- Client-side programming
  - Apache HttpComponents
  - clj-http as wrapper for HttpComponents
- Programming popular RESTful Web-Service Interfaces by  Google and Amazon in Clojure

RESTful web services are easy to use with most modern http libraries. For client-side Clojure the most common solution is ~clj-http~ (https://clojars.org/clj-http / https://github.com/dakrone/clj-http/) which in turn is based on the poplular Apache HttpComponents libraries.

Using ~clj-http~ is straightforward:

#+BEGIN_SRC clojure
(ns b5
  (:require [clj-http.client :as client]))
(client/get "http://www.dradio.de")
#+END_SRC

The return value comes as a standard Clojure map:

#+BEGIN_SRC clojure
{
:cookies {"NSC_esbejp_esbejp" {:discard true, :path "/", :value "ffffffffda4d535d45525d5f4f58455e445a4a423660", :version 0}}, :trace-redirects ["http://www.dradio.de"], :request-time 8894, :status 200, 
[...]
}
#+END_SRC

~clj-http~ supports all standard http operations.

In combination with URITemplates it is possible to run gets:

#+BEGIN_SRC clojure
(use 'uritemplate-clj.core)
(def google-template "http://www.google.com//#hl={language}&q={query}")
(map #(:status (client/get (uritemplate google-template %)))
[{"language" "de", "query" "restful web services"}, {"language" "de", "query" "uritemplate"}])
#+END_SRC

*** Web Services the Google way
Google offers a elegant, well-documented and powerful RESTful interfaces to its services. We will use it here to illustrate key RESTful principles in practice. This means no endorsement of any kind either by or for Google, with which the author has no affiliation.

The web service we are specifically using here is the Calendar API. We will see how to read, create, update and delete entries in a Google calendar.

**** Account and authentication
In a first stage you need to create a test account that is associated ot an email address (not necessarily a GMail account, though), obviously coupled to a password. With this we can look into the Google Console at https://code.google.com/apis/console:

#+CAPTION: Google API console
[[./img/google_console.png]]

After agreeing to various terms of use and activating the Calendar API you are free to use the service. Finally you can access the API key, a long machine generated unique identifier. Then you can authorized API Access that (amongst others) defines a product name, e.g. worms_calendar. Details of that process are described in https://developers.google.com/google-apps/calendar/firstapp and https://developers.google.com/google-apps/calendar/auth.

Authentication APIs are defined in https://developers.google.com/accounts/docs/GettingStarted#OAuth and https://developers.google.com/console/help/?hl=de#UsingKeys. You can interactively test it out using https://developers.google.com/oauthplayground/?hl=de. This way you can also access the relevant access tokens.

#+BEGIN_EXAMPLE
curl -H "Authorization: OAuth ya29.AHES6ZTUrYlO37e8qKFpKVPsCd-4Vd52sFtpR3MSeYB9Php1DZEr" https://www.googleapis.com/calendar/v3/users/me/calendarList
#+END_EXAMPLE

#+BEGIN_SRC clojure
(client/get "https://www.googleapis.com/calendar/v3/users/me/calendarList" {:headers {"Authorization" "OAuth ya29.AHES6ZTUrYlO37e8qKFpKVPsCd-4Vd52sFtpR3MSeYB9Php1DZEr"}})
#+END_SRC
returns a map. The body is encoded in JSON that we can parse with Cheshire:


**** Accessing the API
I assume that we've obtained via OAuth2, e.g. using the OAuth 2.0 Playground, a valid access token.

#+BEGIN_SRC clojure
(def calender-list (client/get "https://www.googleapis.com/calendar/v3/users/me/calendarList" {:headers {"Authorization" "OAuth ya29.AHES6ZTUrYlO37e8qKFpKVPsCd-4Vd52sFtpR3MSeYB9Php1DZEr"}}))
(cheshire.core/parse-string (:body calender-list))
-->
{"kind" "calendar#calendarList", "etag" "\"940AbKLY6Usoo_WM4FY1utLF0hE/e3lCLkYVmdQwpp-Hfz7EeWMNxPA\"", "items" [{"defaultReminders" [{"method" "popup", "minutes" 30}], "foregroundColor" "#000000", "summary" "Web Services", "kind" "calendar#calendarListEntry", "etag" "\"940AbKLY6Usoo_WM4FY1utLF0hE/rr4G0y99XbqGdzSe2AOgZd0x12s\"", "backgroundColor" "#d06b64", "location" "Worms", "timeZone" "Europe/Berlin", "accessRole" "owner", "id" "XXXXX@googlemail.com", "colorId" "2"} {"foregroundColor" "#000000", "summary" "Privat", "kind" "calendar#calendarListEntry", "etag" "\"940AbKLY6Usoo_WM4FY1utLF0hE/16xw2sMaLL8vMyKzEGcRcZFPZBE\"", "backgroundColor" "#f691b2", "location" "Worms", "timeZone" "Europe/Berlin", "accessRole" "owner", "id" "u2nkrgh7m4hqvofv2nfn9jgnb8@group.calendar.google.com", "description" "Privater Kalender", "colorId" "22"}]}
#+END_SRC

We can then process the return value using standard Clojure operations:
#+BEGIN_SRC clojure
b5> (map #(get % "id")  (get (cheshire.core/parse-string (:body (client/get "https://www.googleapis.com/calendar/v3/users/me/calendarList" {:headers {"Authorization" "OAuth ya29.AHES6ZTn3crVvDHPVBldT2yXaec1hJqk9dsFeEW_oYs"}})              )) "items"))
("XXXXX@googlemail.com" "u2nkrgh7m4hqvofv2nfn9jgnb8@group.calendar.google.com")
b5> 
#+END_SRC

This information can now be used to attack individual calendars and e.g. read all events stored in them.

Details of the calendar API are documented under https://developers.google.com/google-apps/calendar/

#+BEGIN_SRC clojure
(client/get "https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events" {:headers {"Authorization" "OAuth ya29.AHES6ZTn3crVvDHPVBldT2yXaec1hJqk9dsFeEW_oYs"}})

(map #(get % "summary") (get (cheshire.core/parse-string (:body (client/get "https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events" {:headers {"Authorization" "OAuth ya29.AHES6ZQ_OFaA6RX0VqilLznX6DJOKGBvCChoFB_Mff8"}}))) "items"))
-->
("Web 3" "Schwimmen gehen" "Essen" "Brief schreiben" "Spazierengehen#" "Essen gehen" "Essen gehen" "Web 3" "test" "test" "ZERRIK URA" "ZERRIK URA" "Test" "Gelibesuchen" "Gelibesuchen" "B5 Nachholtermin" "Mensaessen" "Besprechung" "Test in B5" "Pratikum" "Pratikum heute Nachmittag" "Schwimmen" "Schwimmen" "Essen" "Schlafen" "Test0815" "Test0815" "Test0815" "Test0815" "Test0815" "Test0815" "web3" "Test0815" "Test0815" "Test0815" "Test0815" "Fahrrad" "Test0815" "Fahrrad" "Editierter Titel" "Vorlesung im O206" "Huepfen" "H��rdenlauf" "zweiter eintrag" "Test0815" "Test0815" "web3" "Test Eintrag in Web3" "Neuer Termin" "XYZ&" "New4r" "Test0815" "Wir gehen huepfen" "test")
#+END_SRC

The same mechanism can then also be used to add new events by sending a suitable JSON request:

#+BEGIN_EXAMPLE
{"start":{"dateTime":"2012-10-20T10:00:00.000-01:00"},"summary":"B5 Lecture today","location":"A126","attendees":["abc@xy.de"],"end":{"dateTime":"2012-10-20T15:00:00.000-01:00"}}
#+END_EXAMPLE

In Clojure the corresponding code looks like this:

#+BEGIN_SRC clojure
(def event (cheshire.core/generate-string {"summary" "B5 Lecture today", "location" "A126", "start"  {"dateTime" "2012-10-20T10:00:00.000-01:00"}, "end" {"dateTime" "2012-10-20T15:00:00.000-01:00"}, "attendees" ["abc@xy.de"]}))

(client/post "https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events" {:headers {"Authorization" "OAuth ya29.AHES6ZQ_OFaA6RX0VqilLznX6DJOKGBvCChoFB_Mff8"} :content-type :json :body event}) 
#+END_SRC

If successful the method returns a 200 JSON struture repeating the full information about the created entry. Most importantly, it also returns the event id that can afterwards be used to modify the created entry.

#+BEGIN_EXAMPLE
(get (cheshire.core/parse-string (:body (client/post "https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events" {:headers {"Authorization" "OAuth ya29.AHES6ZQ_OFaA6RX0VqilLznX6DJOKGBvCChoFB_Mff8"} :content-type :json :body event}))) "id")
-->
"74bvi6025o76q1ffpalst8ih60"
#+END_EXAMPLE

With this information we can update (= ~PUT~) the event:
#+BEGIN_EXAMPLE
(def modified-event (cheshire.core/generate-string {"summary" "B5 Lecture today, prolonged", "location" "A126", "start"  {"dateTime" "2012-10-20T10:00:00.000-01:00"}, "end" {"dateTime" "2012-10-20T16:00:00.000-01:00"}, "attendees" ["abc@xy.de"]}))
(client/put "https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events/74bvi6025o76q1ffpalst8ih60" {:headers {"Authorization" "OAuth ya29.AHES6ZQ_OFaA6RX0VqilLznX6DJOKGBvCChoFB_Mff8"} :content-type :json :body modified-event})
#+END_EXAMPLE

or even delete it again
#+BEGIN_EXAMPLE
(client/delete "https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events/74bvi6025o76q1ffpalst8ih60" {:headers {"Authorization" "OAuth ya29.AHES6ZQ_OFaA6RX0VqilLznX6DJOKGBvCChoFB_Mff8"}})
-->
{:trace-redirects ["https://www.googleapis.com/calendar/v3/calendars/XXXXX@googlemail.com/events/74bvi6025o76q1ffpalst8ih60"], :request-time 586, :status 204, :headers {"cache-control" "no-cache, no-store, max-age=0, must-revalidate", "pragma" "no-cache", "expires" "Fri, 01 Jan 1990 00:00:00 GMT", "date" "Fri, 19 Oct 2012 17:27:54 GMT", "etag" "\"xuTtQAt8DDsZ3NJgXaKj-AnoGow/W6k8nbDP-T9StSHXQg5D9u2ieE8\"", "server" "GSE", "connection" "close"}, :body nil}
#+END_EXAMPLE

*** Assignment

1. For the Google Calendar API describe the CRUD (= Create / Update / Delete) operations for events as a URITemplate and use that URITemplate for further operations

2. Develop a command line application in Clojure that takes as parameter an access token, a mode (create, update, delete) and 
   - for create: a title, a start and an end date, and a list of participants as email addresses
   - for update: an event id, a title, a start and an end date, and a list of participants as email addresses
   - for delete: an event id

   The application inserts / modifies / deletes the event in the Calendar. To simpliy things you can assume that you always get all parameters in the sequence mentioned above on the command line, e.g.:

#+BEGIN_EXAMPLE
lein run ACCESS-KEY MODE PARAMETER1 PARAMETER2...
#+END_EXAMPLE

3. Enhance the command line application so that it lists all of today's events

Work in teams of two, but hand in the results individually via the project's Moodle page. Indicate in the comments your team partner.



** Server-side REST 
Session <2012-11-02 Fri>
- Server-side programming 
  - Ring, a Clojure web applications library
  - Integration with Jetty and other Servlet containers
  - Deploying Web Applications


https://clojars.org/clj-oauth2
https://github.com/DerGuteMoritz/clj-oauth2

http://coderwall.com/p/y9w4-g: explanation, full set depends on server side programs


*** Assignment

# Write a ATOM publisher in Clojure using the ROME library that consumes at least two existing feeds, then uses Java interop to access SyndFeed (https://rometools.jira.com/wiki/display/ROME/Rome+v0.4+Tutorial%2C+Using+Rome+to+create+and+write+a+syndication+feed) to create a new aggregation feed based on the source feeds. Use ring to set up a server to publish the resulting feed. 

* SOAP-based Web Services and Service-oriented Architectures 
Session <2012-11-03 Sat>
- XML Schema
  - Syntax
  - Content models
  - Choice and All
- Interface descriptions: WSDL

Session <2012-11-16 Fri>
- SOAP 
- Tools: soapUI
- Tools to check the data flow (e.g. tcpMon)
- Services: SOAs: heterogeneous, loosely-coupled architectures
- Concepts of semantic and organizational interoperability

* Programming SOAP-based Web Services
Session <2012-11-17 Sat> 
- Popular JVM libraries for SOAP-based services
  - Apache Axis 2 and clj-soap (https://clojars.org/org.clojars.seancorfield/clj-soap)
  - Jax-RPC 2.0 / JAX-WS 2.0 (http://www.artima.com/lejava/articles/threeminutes.html, http://stackoverflow.com/questions/2855292/scala-simple-webservice, https://gist.github.com/381129)
- Implementing clients for existing simple SOAP services in Clojure
  - Generation of stubs
  - Analysis of stubs
- Implementing simple SOAP services in Clojure



* Excursion: Web Services in .NET
Special guest: Lukas Georgieff, talking about SOAP-based and RESTful web services on the .NET platform using C#

Session <2012-11-30 Fri>
- .Net-Framework
- Windows Communication Foundation
  - Architecture
  - Contracts and Description
  - Service Runtime
  - Messaging
  - Hosting and Activation
- SOAP and WCF
  - Music Store (Service)
    - Requirements
    - Implementation
      - Create a Visual Studio WCF-Project
      - Service and Operation Contracts
      - Message and Data Contracts
      - loginUser and postUserImage
      - Binding
    - Live Coding: Echo Service
  - Music Store (Client): Implementation
    - Service-Reference
    - Calling Stub-Methods

Session <2012-12-01 Sat>
- RESTful and WCF
   - Music Store (Service)
     - Implementation
       - Service and Operation Contracts
       - UriTemplate, WebGet and WebInvoke
       - Data Contracts
       - loginUser, postUserImage and WebOperationContext
       - Binding
    - Live Coding: Echo Service
    - Music Store (Client): Implementation
      - WebChannelFactory
      - Implementing a RESTful Stub

* The Semantic Web
Session <2012-12-14 Fri>
- What are Ontologies? Ontologies and Us
- Ontologies and Technology
  - Standards
    - RDF
    - RDF-S
    - OWL
    - SPARQL
  - Object identity
  - Tools
    - Protégé
    - Semantic Stores
- Linked Open Data
- Semantic Web Services

https://clojars.org/seabass

Session <2012-12-15 Sat>
- Programming the Semantic Web

* Preparing the Practical Programming Projects
Sessions <2013-01-04 Fri> and <2013-01-05 Sat>

Clojure-based ecosystems of agents and actors

Twitter-client

* Bibliography
